{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcda My Study Notes","text":"<p>Welcome to my personal knowledge base. This site contains organized notes, diagrams, and code snippets on topics I'm currently studying.</p>"},{"location":"#how-to-use-this-site","title":"\ud83d\udd27 How to Use This Site","text":"<ul> <li>Use the sidebar navigation to browse topics.</li> <li>Each section contains notes, images, and code.</li> <li>Content is always a work in progress \u2014 I update it regularly.</li> </ul>"},{"location":"#how-to-contribute-to-the-notes","title":"\u2795 How to Contribute to the notes","text":"<ul> <li>If you find any errors, have suggestions or want to add topics, please open an issue or pull request on https://github.com/hrs070/cs-notes</li> <li>Follow the same formatting and structure as the existing notes.</li> </ul>"},{"location":"#topics-covered","title":"\ud83d\ude80 Topics Covered","text":"<ul> <li>Computer Science Fundamentals</li> <li>Operating Systems</li> <li>Networking</li> <li>Databases</li> <li> <p>Data Structures &amp; Algorithms</p> </li> <li> <p>Software Engineering</p> </li> <li>System Design</li> <li>Design Patterns</li> <li> <p>Coding Best Practices</p> </li> <li> <p>Programming Languages</p> </li> <li>Shell script</li> <li>Go</li> <li>TypeScript / Node.js</li> <li> <p>Python (for tooling)</p> </li> <li> <p>Tools &amp; Ecosystem</p> </li> <li>Git &amp; GitHub</li> <li>CLI Tools</li> <li>DevOps Basics</li> <li>Kubernetes</li> </ul>"},{"location":"tips-and-snippets/","title":"Tips &amp; Snippets","text":"Tool/Topic Command/Code Example Description Jenkins Credential Decrypt <code>println hudson.util.Secret.decrypt(\"{secret}\")</code> Decrypts Jenkins credentials."},{"location":"concepts/acid/","title":"ACID Principle","text":"<p>The ACID principle is a set of properties that ensure reliable processing of database transactions. These properties are crucial for maintaining data integrity in database systems, especially in the event of errors, power failures, or concurrent access by multiple users.</p>"},{"location":"concepts/acid/#summary-table","title":"Summary Table","text":"Property Description Key Mechanisms Example Atomicity Ensures all operations in a transaction are completed or none Undo logs, transaction management systems Bank transfer: rollback if debit succeeds but credit fails Consistency Ensures DB transitions from one valid state to another DB constraints (e.g., primary keys), app-level checks E-commerce: prevent stock from going below zero Isolation Prevents interference between concurrent transactions Isolation levels: Read Uncommitted \u2192 Serializable Flight booking: only one user books the last seat Durability Guarantees committed changes are permanent WAL (Write-Ahead Logging), checkpoints, backups Online purchase: order persists after a system crash"},{"location":"concepts/acid/#what-is-a-transaction","title":"What is a Transaction?","text":"<p>A transaction is a sequence of one or more operations performed as a single logical unit of work. A transaction must adhere to the ACID properties to ensure consistency and reliability in a database.</p>"},{"location":"concepts/acid/#acid-properties","title":"ACID Properties","text":""},{"location":"concepts/acid/#1-atomicity","title":"1. Atomicity","text":"<p>Atomicity ensures that a transaction is treated as a single, indivisible unit. Either all operations in the transaction are completed successfully, or none of them are applied. This prevents partial updates to the database.</p>"},{"location":"concepts/acid/#key-mechanisms","title":"Key Mechanisms:","text":"<ul> <li>Undo logs are often used to roll back incomplete transactions.</li> <li>Transaction management systems ensure atomicity by marking transactions as either \"committed\" or \"aborted.\"</li> </ul>"},{"location":"concepts/acid/#example","title":"Example:","text":"<p>Consider a bank transfer where $100 is moved from Account A to Account B: - Debit $100 from Account A. - Credit $100 to Account B.</p> <p>If the system crashes after debiting Account A but before crediting Account B, atomicity ensures that the transaction is rolled back, leaving both accounts unchanged.</p>"},{"location":"concepts/acid/#2-consistency","title":"2. Consistency","text":"<p>Consistency ensures that a transaction brings the database from one valid state to another. Any rules, constraints, or integrity conditions defined in the database must be preserved after the transaction is completed.</p>"},{"location":"concepts/acid/#key-mechanisms_1","title":"Key Mechanisms:","text":"<ul> <li>Database constraints such as primary keys, foreign keys, and unique constraints help enforce consistency.</li> <li>Application-level validations also contribute to maintaining consistency.</li> </ul>"},{"location":"concepts/acid/#example_1","title":"Example:","text":"<p>In an e-commerce application: - A product's stock level must never go below zero. - If a customer places an order, the stock is reduced only if sufficient inventory exists.</p> <p>If a transaction violates this rule, it will be aborted to maintain consistency.</p>"},{"location":"concepts/acid/#3-isolation","title":"3. Isolation","text":"<p>Isolation ensures that concurrent transactions do not interfere with each other. The intermediate state of a transaction is not visible to other transactions until it is committed.</p>"},{"location":"concepts/acid/#isolation-levels","title":"Isolation Levels:","text":"<ul> <li>Read Uncommitted: Transactions can read uncommitted changes from other transactions (least strict).</li> <li>Read Committed: Transactions can only read committed changes.</li> <li>Repeatable Read: Ensures that data read during a transaction cannot change.</li> <li>Serializable: Ensures complete isolation by serializing transactions (most strict).</li> </ul>"},{"location":"concepts/acid/#example_2","title":"Example:","text":"<p>Two users are attempting to book the last seat on a flight: - User A and User B both try to reserve the seat simultaneously. - Isolation ensures that only one transaction succeeds, and the other is either retried or aborted.</p> <p>This prevents conflicts and ensures accurate results.</p>"},{"location":"concepts/acid/#4-durability","title":"4. Durability","text":"<p>Durability ensures that once a transaction is committed, its changes are permanent, even in the event of a system crash. The database system uses mechanisms like write-ahead logs or backups to guarantee durability.</p>"},{"location":"concepts/acid/#key-mechanisms_2","title":"Key Mechanisms:","text":"<ul> <li>Write-ahead logging (WAL) ensures that changes are written to a log before being applied to the database.</li> <li>Checkpoints and backups are used to recover committed transactions after a crash.</li> </ul>"},{"location":"concepts/acid/#example_3","title":"Example:","text":"<p>After a customer completes an online purchase: - The order details are stored in the database. - Even if the system crashes immediately after the confirmation, the order will still exist when the system is restored.</p>"},{"location":"concepts/acid/#summary","title":"Summary","text":"<p>The ACID properties work together to ensure the reliability and correctness of database transactions: - Atomicity: All or nothing. - Consistency: Valid state transitions. - Isolation: No interference between transactions. - Durability: Changes are permanent after commit.</p>"},{"location":"concepts/cleanCode/","title":"Clean Code","text":""},{"location":"concepts/cleanCode/#introduction","title":"Introduction","text":"<p>\"Clean Code\" by Robert C. Martin is a must-read for software developers who want to write maintainable, efficient, and readable code. This book emphasizes principles, patterns, and practices that help developers produce high-quality code.</p> <p>The following notes summarize key concepts from the book, along with examples in TypeScript to illustrate each principle.</p>"},{"location":"concepts/cleanCode/#1-meaningful-names","title":"1. Meaningful Names","text":""},{"location":"concepts/cleanCode/#principle","title":"Principle","text":"<p>Choosing meaningful and descriptive names for variables, functions, and classes is critical for writing clean code. Names should reveal intent, avoid disinformation, and be pronounceable.</p>"},{"location":"concepts/cleanCode/#guidelines","title":"Guidelines","text":"<ul> <li>Use intention-revealing names.</li> <li>Avoid disinformation.</li> <li>Make names pronounceable.</li> <li>Use searchable names.</li> <li>Avoid encodings or Hungarian notation.</li> </ul>"},{"location":"concepts/cleanCode/#bad-example","title":"\u274c Bad Example","text":"<pre><code>function d(a: number, b: number): number {\n    return a * b / 2;\n}\n\nconst t = d(10, 5);\nconsole.log(t);\n</code></pre>"},{"location":"concepts/cleanCode/#good-example","title":"\u2705 Good Example","text":"<pre><code>function calculateTriangleArea(base: number, height: number): number {\n    return (base * height) / 2;\n}\n\nconst triangleArea = calculateTriangleArea(10, 5);\nconsole.log(triangleArea);\n</code></pre>"},{"location":"concepts/cleanCode/#hard-to-pronounce","title":"\u274c Hard to Pronounce","text":"<pre><code>const genymdhms = \"2025-04-21T10:00:00Z\";\n</code></pre>"},{"location":"concepts/cleanCode/#easy-to-pronounce","title":"\u2705 Easy to Pronounce","text":"<pre><code>const generationTimestamp = \"2025-04-21T10:00:00Z\";\n</code></pre>"},{"location":"concepts/cleanCode/#2-functions","title":"2. Functions","text":""},{"location":"concepts/cleanCode/#principle_1","title":"Principle","text":"<p>Functions should be small, do one thing, and do it well. They should be easy to read, test, and maintain.</p>"},{"location":"concepts/cleanCode/#guidelines_1","title":"Guidelines","text":"<ul> <li>Keep functions small (ideally under 20 lines).</li> <li>Make them do one thing.</li> <li>Use descriptive names.</li> <li>Avoid side effects.</li> <li>Keep the number of arguments low (ideally \u2264 3).</li> </ul>"},{"location":"concepts/cleanCode/#bad-function-does-too-many-things","title":"\u274c Bad: Function does too many things","text":"<pre><code>function processUserData(user: { name: string; age: number; email: string }): void {\n    console.log(`User: ${user.name}`);\n    if (user.age &gt;= 18) {\n        console.log(\"User is an adult.\");\n    } else {\n        console.log(\"User is a minor.\");\n    }\n    sendEmail(user.email, \"Welcome!\");\n}\n</code></pre>"},{"location":"concepts/cleanCode/#good-break-it-down","title":"\u2705 Good: Break it down","text":"<pre><code>function logUserName(name: string): void {\n    console.log(`User: ${name}`);\n}\n\nfunction checkUserAge(age: number): void {\n    if (age &gt;= 18) {\n        console.log(\"User is an adult.\");\n    } else {\n        console.log(\"User is a minor.\");\n    }\n}\n\nfunction sendWelcomeEmail(email: string): void {\n    sendEmail(email, \"Welcome!\");\n}\n\nfunction sendEmail(email: string, message: string): void {\n    console.log(`Sending email to ${email}: ${message}`);\n}\n\nconst user = { name: \"John\", age: 25, email: \"john@example.com\" };\n\nlogUserName(user.name);\ncheckUserAge(user.age);\nsendWelcomeEmail(user.email);\n</code></pre>"},{"location":"concepts/cleanCode/#bad-too-many-arguments","title":"\u274c Bad: Too many arguments","text":"<pre><code>function createUser(name: string, age: number, email: string, isAdmin: boolean): void {\n    console.log(`Name: ${name}, Age: ${age}, Email: ${email}, Admin: ${isAdmin}`);\n}\n</code></pre>"},{"location":"concepts/cleanCode/#good-use-an-object","title":"\u2705 Good: Use an object","text":"<pre><code>interface User {\n    name: string;\n    age: number;\n    email: string;\n    isAdmin: boolean;\n}\n\nfunction createUser(user: User): void {\n    console.log(`Name: ${user.name}, Age: ${user.age}, Email: ${user.email}, Admin: ${user.isAdmin}`);\n}\n\nconst newUser: User = {\n    name: \"Jane\",\n    age: 30,\n    email: \"jane@example.com\",\n    isAdmin: true\n};\n\ncreateUser(newUser);\n</code></pre>"},{"location":"concepts/cleanCode/#3-comments","title":"3. Comments","text":""},{"location":"concepts/cleanCode/#principle_2","title":"Principle","text":"<p>Code should be self-explanatory whenever possible. Use comments to explain \"why\", not \"what\". Avoid redundant, misleading, or outdated comments.</p>"},{"location":"concepts/cleanCode/#good-explains-the-why","title":"\u2705 Good: Explains the why","text":"<pre><code>// Using a Set to improve lookup time\nconst visited = new Set&lt;string&gt;();\n</code></pre>"},{"location":"concepts/cleanCode/#bad-explains-the-obvious","title":"\u274c Bad: Explains the obvious","text":"<pre><code>// Increment i by 1\ni = i + 1;\n</code></pre>"},{"location":"concepts/cleanCode/#4-formatting","title":"4. Formatting","text":""},{"location":"concepts/cleanCode/#principle_3","title":"Principle","text":"<p>Proper formatting improves the readability and maintainability of code. Consistent formatting helps developers quickly understand the structure and flow of the code.</p>"},{"location":"concepts/cleanCode/#guidelines_2","title":"Guidelines","text":"<ul> <li>Use consistent indentation (e.g., 4 spaces per level).</li> <li>Group related code together.</li> <li>Use blank lines to separate unrelated sections of code.</li> <li>Limit line length (e.g., 80\u2013120 characters).</li> <li>Align code for clarity when appropriate.</li> </ul>"},{"location":"concepts/cleanCode/#bad-example_1","title":"\u274c Bad Example","text":"<pre><code>// Bad: Inconsistent indentation and poor grouping\nfunction calculateTotal(items: number[], tax: number): number {\nlet total=0;for(let i=0;i&lt;items.length;i++){total+=items[i];}total+=total*tax;return total;}\n\nconst items=[10,20,30];\nconst tax=0.1;const total=calculateTotal(items,tax);console.log(total);\n</code></pre>"},{"location":"concepts/cleanCode/#good-example_1","title":"\u2705 Good Example","text":"<pre><code>// Good: Consistent indentation and proper grouping\nfunction calculateTotal(items: number[], tax: number): number {\n    let total = 0;\n\n    for (let i = 0; i &lt; items.length; i++) {\n        total += items[i];\n    }\n\n    total += total * tax;\n    return total;\n}\n\n// Usage\nconst items = [10, 20, 30];\nconst tax = 0.1;\nconst total = calculateTotal(items, tax);\nconsole.log(total);\n</code></pre>"},{"location":"concepts/cleanCode/#use-blank-lines-to-separate-concepts","title":"Use Blank Lines to Separate Concepts","text":"<pre><code>// Bad: No separation between unrelated code\nconst user = { name: \"Alice\", age: 25 };\nconsole.log(user.name); const items = [1, 2, 3]; console.log(items.length);\n\n// Good: Add blank lines to separate concepts\nconst user = { name: \"Alice\", age: 25 };\nconsole.log(user.name);\n\nconst items = [1, 2, 3];\nconsole.log(items.length);\n</code></pre>"},{"location":"concepts/cleanCode/#limit-line-length","title":"Limit Line Length","text":"<pre><code>// Bad: Line is too long\nconst message = \"This is a very long message that exceeds the recommended line length and makes the code harder to read.\";\n\n// Good: Break long lines into multiple lines\nconst message = \"This is a very long message that exceeds the recommended line length \" +\n                \"and makes the code harder to read.\";\n</code></pre>"},{"location":"concepts/cleanCode/#5-error-handling","title":"5. Error Handling","text":""},{"location":"concepts/cleanCode/#principle_4","title":"Principle","text":"<p>Error handling is an essential part of writing clean code. It should be done gracefully and in a way that does not obscure the logic of the program. Avoid cluttering the code with error-handling logic and ensure that errors are handled consistently.</p>"},{"location":"concepts/cleanCode/#guidelines_3","title":"Guidelines","text":"<ul> <li>Use exceptions instead of return codes to handle errors.</li> <li>Provide meaningful error messages that describe the problem clearly.</li> <li>Handle exceptions at the appropriate level where they can be meaningfully addressed.</li> <li>Avoid swallowing exceptions without taking action or rethrowing them.</li> <li>Use custom exceptions to represent specific error conditions.</li> </ul>"},{"location":"concepts/cleanCode/#bad-example-using-return-codes","title":"\u274c Bad Example: Using Return Codes","text":"<pre><code>// Bad: Using return codes for error handling\nfunction divide(a: number, b: number): number | null {\n    if (b === 0) {\n        return null; // Error case\n    }\n    return a / b;\n}\n\nconst result = divide(10, 0);\nif (result === null) {\n    console.log(\"Error: Division by zero\");\n} else {\n    console.log(result);\n}\n</code></pre>"},{"location":"concepts/cleanCode/#good-example-using-exceptions","title":"\u2705 Good Example: Using Exceptions","text":"<pre><code>// Good: Using exceptions for error handling\nfunction divide(a: number, b: number): number {\n    if (b === 0) {\n        throw new Error(\"Division by zero is not allowed\");\n    }\n    return a / b;\n}\n\ntry {\n    const result = divide(10, 0);\n    console.log(result);\n} catch (error) {\n    console.error(error.message);\n}\n</code></pre>"},{"location":"concepts/cleanCode/#provide-meaningful-error-messages","title":"Provide Meaningful Error Messages","text":"<pre><code>// Bad: Generic error message\nthrow new Error(\"Something went wrong\");\n\n// Good: Specific error message\nthrow new Error(\"Invalid user ID: User ID must be a positive integer\");\n</code></pre>"},{"location":"concepts/cleanCode/#handle-exceptions-at-the-appropriate-level","title":"Handle Exceptions at the Appropriate Level","text":"<pre><code>// Bad: Catching exceptions too early\ntry {\n    const data = fetchDataFromAPI();\n    processData(data);\n} catch (error) {\n    console.error(\"Error occurred\"); // No meaningful handling\n}\n\n// Good: Catch exceptions where they can be handled meaningfully\nfunction fetchDataAndProcess(): void {\n    try {\n        const data = fetchDataFromAPI();\n        processData(data);\n    } catch (error) {\n        console.error(\"Failed to fetch or process data:\", error.message);\n    }\n}\n</code></pre>"},{"location":"concepts/cleanCode/#use-custom-exceptions","title":"Use Custom Exceptions","text":"<pre><code>// Good: Define a custom exception\nclass InvalidUserInputError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"InvalidUserInputError\";\n    }\n}\n\nfunction validateUserInput(input: string): void {\n    if (input.trim() === \"\") {\n        throw new InvalidUserInputError(\"Input cannot be empty\");\n    }\n}\n\n// Usage\ntry {\n    validateUserInput(\"\");\n} catch (error) {\n    if (error instanceof InvalidUserInputError) {\n        console.error(\"User input error:\", error.message);\n    } else {\n        console.error(\"Unexpected error:\", error.message);\n    }\n}\n</code></pre>"},{"location":"concepts/cleanCode/#6-classes","title":"6. Classes","text":""},{"location":"concepts/cleanCode/#principle_5","title":"Principle","text":"<p>Classes should be small and focused, just like functions. A class should have a single responsibility and encapsulate related data and behavior. Avoid creating large, monolithic classes that try to do too much.</p>"},{"location":"concepts/cleanCode/#guidelines_4","title":"Guidelines","text":"<ul> <li>Follow the Single Responsibility Principle (SRP): A class should have only one reason to change.</li> <li>Keep classes small and cohesive.</li> <li>Use meaningful names for classes that describe their purpose.</li> <li>Encapsulate internal details and expose only what is necessary through public methods.</li> <li>Prefer composition over inheritance when possible.</li> </ul>"},{"location":"concepts/cleanCode/#bad-example-large-monolithic-class","title":"\u274c Bad Example: Large, Monolithic Class","text":"<pre><code>// Bad: Class does too many things\nclass UserManager {\n    private users: { name: string; email: string }[] = [];\n\n    addUser(name: string, email: string): void {\n        this.users.push({ name, email });\n    }\n\n    removeUser(email: string): void {\n        this.users = this.users.filter((user) =&gt; user.email !== email);\n    }\n\n    sendEmail(email: string, message: string): void {\n        console.log(`Sending email to ${email}: ${message}`);\n    }\n\n    listUsers(): void {\n        console.log(this.users);\n    }\n}\n</code></pre>"},{"location":"concepts/cleanCode/#good-example-break-it-down","title":"\u2705 Good Example: Break It Down","text":"<pre><code>// Good: Separate responsibilities into smaller classes\nclass User {\n    constructor(public name: string, public email: string) {}\n}\n\nclass UserRepository {\n    private users: User[] = [];\n\n    addUser(user: User): void {\n        this.users.push(user);\n    }\n\n    removeUser(email: string): void {\n        this.users = this.users.filter((user) =&gt; user.email !== email);\n    }\n\n    getUsers(): User[] {\n        return this.users;\n    }\n}\n\nclass EmailService {\n    sendEmail(email: string, message: string): void {\n        console.log(`Sending email to ${email}: ${message}`);\n    }\n}\n\n// Usage\nconst userRepository = new UserRepository();\nconst emailService = new EmailService();\n\nconst user = new User(\"John Doe\", \"john@example.com\");\nuserRepository.addUser(user);\n\nemailService.sendEmail(user.email, \"Welcome to our platform!\");\nconsole.log(userRepository.getUsers());\n</code></pre>"},{"location":"concepts/cleanCode/#encapsulation-example","title":"Encapsulation Example","text":"<pre><code>// Good: Encapsulate internal details\nclass BankAccount {\n    private balance: number;\n\n    constructor(initialBalance: number) {\n        this.balance = initialBalance;\n    }\n\n    deposit(amount: number): void {\n        if (amount &lt;= 0) {\n            throw new Error(\"Deposit amount must be positive\");\n        }\n        this.balance += amount;\n    }\n\n    withdraw(amount: number): void {\n        if (amount &gt; this.balance) {\n            throw new Error(\"Insufficient funds\");\n        }\n        this.balance -= amount;\n    }\n\n    getBalance(): number {\n        return this.balance;\n    }\n}\n\n// Usage\nconst account = new BankAccount(100);\naccount.deposit(50);\naccount.withdraw(30);\nconsole.log(account.getBalance()); // Output: 120\n</code></pre>"},{"location":"concepts/cleanCode/#7-testing","title":"7. Testing","text":""},{"location":"concepts/cleanCode/#principle_6","title":"Principle","text":"<p>Testing is an essential part of writing clean code. Tests ensure that your code works as expected and remains maintainable over time. Clean tests are easy to read, understand, and maintain. They should focus on verifying behavior, not implementation details.</p>"},{"location":"concepts/cleanCode/#guidelines_5","title":"Guidelines","text":"<ul> <li>Write tests that are easy to read and understand.</li> <li>Follow the FIRST principles:<ul> <li>Fast: Tests should run quickly.</li> <li>Independent: Tests should not depend on each other.</li> <li>Repeatable: Tests should produce the same results every time.</li> <li>Self-validating: Tests should automatically verify success or failure.</li> <li>Timely: Write tests as soon as possible, ideally before writing the code (TDD).</li> </ul> </li> <li>Use descriptive names for test cases.</li> <li>Test one thing at a time.</li> <li>Avoid testing implementation details; focus on behavior.</li> </ul>"},{"location":"concepts/cleanCode/#bad-example-hard-to-read-test","title":"\u274c Bad Example: Hard-to-Read Test","text":"<pre><code>// Bad: Test is hard to read and understand\ntest(\"should add user\", () =&gt; {\n    const u = new User(\"John\", \"john@example.com\");\n    const repo = new UserRepository();\n    repo.addUser(u);\n    expect(repo.getUsers().length).toBe(1);\n    expect(repo.getUsers()[0].name).toBe(\"John\");\n});\n</code></pre>"},{"location":"concepts/cleanCode/#good-example-clean-and-readable-test","title":"\u2705 Good Example: Clean and Readable Test","text":"<pre><code>// Good: Test is clean and descriptive\ntest(\"should add a user to the repository\", () =&gt; {\n    // Arrange\n    const user = new User(\"John\", \"john@example.com\");\n    const userRepository = new UserRepository();\n\n    // Act\n    userRepository.addUser(user);\n\n    // Assert\n    const users = userRepository.getUsers();\n    expect(users).toHaveLength(1);\n    expect(users[0].name).toBe(\"John\");\n    expect(users[0].email).toBe(\"john@example.com\");\n});\n</code></pre>"},{"location":"concepts/cleanCode/#use-mocks-and-stubs-for-dependencies","title":"Use Mocks and Stubs for Dependencies","text":"<pre><code>// Example: Mocking an email service\nclass MockEmailService {\n    sendEmail(email: string, message: string): void {\n        console.log(`Mock email sent to ${email}: ${message}`);\n    }\n}\n\ntest(\"should send a welcome email\", () =&gt; {\n    // Arrange\n    const emailService = new MockEmailService();\n    const user = new User(\"Jane\", \"jane@example.com\");\n\n    // Act\n    emailService.sendEmail(user.email, \"Welcome!\");\n\n    // Assert\n    // (In a real test, you would verify that the email was sent correctly)\n});\n</code></pre>"},{"location":"concepts/cleanCode/#test-edge-cases","title":"Test Edge Cases","text":"<pre><code>// Example: Testing edge cases for a bank account\ntest(\"should throw an error when withdrawing more than the balance\", () =&gt; {\n    const account = new BankAccount(100);\n\n    expect(() =&gt; account.withdraw(200)).toThrow(\"Insufficient funds\");\n});\n\ntest(\"should throw an error when depositing a negative amount\", () =&gt; {\n    const account = new BankAccount(100);\n\n    expect(() =&gt; account.deposit(-50)).toThrow(\"Deposit amount must be positive\");\n});\n</code></pre>"},{"location":"concepts/cleanCode/#8-general-principles","title":"8. General Principles","text":""},{"location":"concepts/cleanCode/#principle_7","title":"Principle","text":"<p>Clean code is guided by a set of overarching principles that help developers write maintainable, efficient, and readable code. These principles ensure that the codebase remains simple, consistent, and free of unnecessary complexity.</p>"},{"location":"concepts/cleanCode/#guidelines_6","title":"Guidelines","text":"<ol> <li>Keep It Simple, Stupid (KISS): Avoid overengineering and keep the code as simple as possible.</li> <li>Don't Repeat Yourself (DRY): Eliminate duplication by abstracting common logic into reusable components.</li> <li>You Aren't Gonna Need It (YAGNI): Do not implement features or functionality until they are actually needed.</li> <li>Separation of Concerns (SoC): Divide the code into distinct sections, each responsible for a specific concern or functionality.</li> <li>Open/Closed Principle: Code should be open for extension but closed for modification.</li> <li>Single Responsibility Principle (SRP): A class or function should have only one reason to change.</li> <li>Fail Fast: Write code that fails early and clearly when something goes wrong.</li> </ol>"},{"location":"concepts/cleanCode/#examples-in-typescript","title":"Examples in TypeScript","text":""},{"location":"concepts/cleanCode/#kiss-keep-it-simple","title":"KISS: Keep It Simple","text":"<pre><code>// Bad: Overengineered solution\nclass MathOperations {\n    static add(a: number, b: number): number {\n        return a + b;\n    }\n\n    static subtract(a: number, b: number): number {\n        return a - b;\n    }\n}\n\nconst result = MathOperations.add(5, 3);\nconsole.log(result);\n\n// Good: Simple and straightforward\nconst result = 5 + 3;\nconsole.log(result);\n</code></pre>"},{"location":"concepts/cleanCode/#dry-dont-repeat-yourself","title":"DRY: Don't Repeat Yourself","text":"<pre><code>// Bad: Repeated logic\nfunction calculateCircleArea(radius: number): number {\n    return Math.PI * radius * radius;\n}\n\nfunction calculateSphereVolume(radius: number): number {\n    return (4 / 3) * Math.PI * radius * radius * radius;\n}\n\n// Good: Abstract common logic\nfunction calculatePower(base: number, exponent: number): number {\n    return Math.pow(base, exponent);\n}\n\nfunction calculateCircleArea(radius: number): number {\n    return Math.PI * calculatePower(radius, 2);\n}\n\nfunction calculateSphereVolume(radius: number): number {\n    return (4 / 3) * Math.PI * calculatePower(radius, 3);\n}\n</code></pre>"},{"location":"concepts/cleanCode/#yagni-you-arent-gonna-need-it","title":"YAGNI: You Aren't Gonna Need It","text":"<pre><code>// Bad: Adding unnecessary functionality\nclass User {\n    constructor(public name: string, public email: string) {}\n\n    // Unused method\n    getFullName(): string {\n        return this.name;\n    }\n}\n\n// Good: Only implement what is needed\nclass User {\n    constructor(public name: string, public email: string) {}\n}\n</code></pre>"},{"location":"concepts/cleanCode/#fail-fast","title":"Fail Fast","text":"<pre><code>// Bad: Fails silently\nfunction getUserById(id: number): User | null {\n    if (id &lt;= 0) {\n        return null; // Invalid ID\n    }\n    // Fetch user logic...\n    return new User(\"John\", \"john@example.com\");\n}\n\n// Good: Fails fast with clear error\nfunction getUserById(id: number): User {\n    if (id &lt;= 0) {\n        throw new Error(\"Invalid user ID\");\n    }\n    // Fetch user logic...\n    return new User(\"John\", \"john@example.com\");\n}\n</code></pre>"},{"location":"concepts/oop/","title":"\ud83d\udcd8 Object-Oriented Programming (OOP)","text":"<p>Object-Oriented Programming (OOP) is a programming paradigm based on the concept of objects, which are instances of classes. It allows modeling complex software systems using real-world metaphors, focusing on data + behavior.</p>"},{"location":"concepts/oop/#key-terminologies","title":"\ud83d\udd24 Key Terminologies","text":"Term Description Class A blueprint/template for creating objects. Object An instance of a class with actual values and behavior. Property / Attribute Variables inside an object (state). Method Functions defined inside a class (behavior). Superclass / Base class A class whose features are inherited. Subclass / Derived class A class that inherits features from another. Constructor A special method used to initialize objects. this Refers to the current instance of the class. super Refers to the parent class and is used to call its methods or constructor. static A keyword to define methods or properties that belong to the class itself, not instances."},{"location":"concepts/oop/#pillars-of-oop","title":"\ud83e\uddf1 Pillars of OOP","text":"<p>The four main pillars of OOP are Encapsulation, Abstraction, Inheritance, and Polymorphism. Let\u2019s explore each concept with explanations and TypeScript examples.</p>"},{"location":"concepts/oop/#1-encapsulation","title":"1. Encapsulation","text":"<p>Definition: Wrapping data and methods that operate on the data into a single unit and restricting direct access to some components.</p> <p>Terminologies:  </p> <ul> <li><code>private</code>, <code>protected</code>, and <code>public</code> access modifiers control visibility.</li> </ul> <p>Explanation:</p> <ul> <li><code>private</code>: Accessible only within the class.</li> <li><code>protected</code>: Accessible within the class and its subclasses.</li> <li><code>public</code>: Accessible from anywhere.</li> </ul> <p>TypeScript Example:</p> <pre><code>class User {\n    private password: string;\n\n    constructor(private username: string, password: string) {\n        this.password = password;\n    }\n\n    public authenticate(input: string): boolean {\n        return this.password === input;\n    }\n\n    public getUsername(): string {\n        return this.username;\n    }\n}\n\nconst user = new User(\"john_doe\", \"secret123\");\nconsole.log(user.authenticate(\"wrong\")); // false\nconsole.log(user.getUsername());         // \"john_doe\"\n// user.password = \"hack\"; \u274c Not allowed \u2013 password is private\n</code></pre> <p>Benefits:</p> <ul> <li>Protects internal state.</li> <li>Encourages using methods to interact with data.</li> </ul>"},{"location":"concepts/oop/#2-abstraction","title":"2. Abstraction","text":"<p>Definition: Hiding internal implementation details and showing only the necessary parts to the user.</p> <p>Terminologies: </p> <ul> <li><code>abstract class</code>, <code>interface</code>, <code>public methods</code></li> </ul> <p>Explanation:</p> <ul> <li>Abstract Class: A class that cannot be instantiated and is meant to be extended by other classes.</li> <li>Interface: Defines a contract that classes must follow.</li> </ul> <p>TypeScript Example:</p> <pre><code>abstract class PaymentProcessor {\n    abstract process(amount: number): void;\n}\n\nclass CreditCardProcessor extends PaymentProcessor {\n    process(amount: number): void {\n        console.log(`Processing \u20b9${amount} using Credit Card`);\n    }\n}\n\nfunction payBill(processor: PaymentProcessor) {\n    processor.process(1000);\n}\n\npayBill(new CreditCardProcessor());\n</code></pre> <p>Benefits:</p> <ul> <li>Users don\u2019t need to understand internals.</li> <li>Provides a clear interface.</li> </ul>"},{"location":"concepts/oop/#3-inheritance","title":"3. Inheritance","text":"<p>Definition: Mechanism by which one class (subclass) can inherit properties and methods from another class (superclass).</p> <p>Terminologies: </p> <ul> <li><code>extends</code>: Used to inherit from a parent class.</li> <li><code>super</code>: Used to call the parent class\u2019s constructor or methods.</li> </ul> <p>Explanation:</p> <ul> <li><code>super</code> in Constructor: Used to initialize the parent class.</li> <li><code>super</code> in Methods: Used to call the parent class\u2019s methods.</li> </ul> <p>TypeScript Example:</p> <pre><code>class Animal {\n    constructor(public name: string) {}\n\n    speak(): void {\n        console.log(`${this.name} makes a sound`);\n    }\n}\n\nclass Dog extends Animal {\n    constructor(name: string, public breed: string) {\n        super(name); // Call the parent class constructor\n    }\n\n    speak(): void {\n        super.speak(); // Call the parent class method\n        console.log(`${this.name} barks`);\n    }\n}\n\nconst dog = new Dog(\"Buddy\", \"Golden Retriever\");\ndog.speak();\n// Output:\n// Buddy makes a sound\n// Buddy barks\n</code></pre> <p>Benefits:</p> <ul> <li>Code reuse.</li> <li>Logical hierarchy of types.</li> </ul>"},{"location":"concepts/oop/#4-polymorphism","title":"4. Polymorphism","text":"<p>Definition: Ability of a single function or method to work in different ways based on the object type.</p> <p>Terminologies: </p> <ul> <li><code>method overriding</code>: Subclass provides a specific implementation of a method defined in the parent class.</li> <li><code>method overloading</code>: Multiple methods with the same name but different parameters (not natively supported in TypeScript).</li> </ul> <p>TypeScript Example:</p> <pre><code>class Shape {\n    draw(): void {\n        console.log(\"Drawing a shape\");\n    }\n}\n\nclass Circle extends Shape {\n    draw(): void {\n        console.log(\"Drawing a circle\");\n    }\n}\n\nclass Square extends Shape {\n    draw(): void {\n        console.log(\"Drawing a square\");\n    }\n}\n\nfunction render(shape: Shape) {\n    shape.draw();\n}\n\nrender(new Circle()); // \"Drawing a circle\"\nrender(new Square()); // \"Drawing a square\"\n</code></pre> <p>Benefits:</p> <ul> <li>Extensibility.</li> <li>Reusability of common interfaces with different implementations.</li> </ul>"},{"location":"concepts/oop/#5-static-methods-and-properties","title":"5. Static Methods and Properties","text":"<p>Definition: <code>static</code> methods and properties belong to the class itself, not to any instance of the class.</p> <p>Explanation:</p> <ul> <li>Static members are accessed using the class name, not an instance.</li> <li>Useful for utility functions or shared data.</li> </ul> <p>TypeScript Example:</p> <pre><code>class MathUtils {\n    static PI: number = 3.14;\n\n    static calculateArea(radius: number): number {\n        return this.PI * radius * radius;\n    }\n}\n\nconsole.log(MathUtils.PI); // 3.14\nconsole.log(MathUtils.calculateArea(5)); // 78.5\n</code></pre> <p>Benefits:</p> <ul> <li>No need to create an instance for common functionality.</li> <li>Shared across all instances.</li> </ul>"},{"location":"concepts/oop/#6-this-keyword","title":"6. <code>this</code> Keyword","text":"<p>Definition: Refers to the current instance of the class.</p> <p>Explanation:</p> <ul> <li>Used to access instance properties and methods.</li> <li>Its value depends on the context in which it is called.</li> </ul> <p>TypeScript Example:</p> <pre><code>class Counter {\n    private count: number = 0;\n\n    increment(): void {\n        this.count++;\n        console.log(`Count: ${this.count}`);\n    }\n}\n\nconst counter = new Counter();\ncounter.increment(); // Count: 1\ncounter.increment(); // Count: 2\n</code></pre>"},{"location":"concepts/oop/#7-super-keyword","title":"7. <code>super</code> Keyword","text":"<p>Definition: Refers to the parent class and is used to call its methods or constructor.</p> <p>TypeScript Example:</p> <pre><code>class Parent {\n    greet(): void {\n        console.log(\"Hello from Parent\");\n    }\n}\n\nclass Child extends Parent {\n    greet(): void {\n        super.greet(); // Call parent method\n        console.log(\"Hello from Child\");\n    }\n}\n\nconst child = new Child();\nchild.greet();\n// Output:\n// Hello from Parent\n// Hello from Child\n</code></pre>"},{"location":"concepts/oop/#pillars-comparison","title":"\ud83d\udcca Pillars Comparison","text":"Principle Purpose Key Concept Real-world Analogy Encapsulation Protect data and expose behavior <code>private</code>, <code>public</code> ATM machine \u2013 you use interface but don\u2019t access internals Abstraction Hide complexity, show essentials <code>abstract class</code>, <code>interface</code> Car dashboard \u2013 you press \"start\", not knowing how it works Inheritance Reuse behavior <code>extends</code>, <code>super</code> Dog is a kind of Animal Polymorphism Same function, different behavior <code>overriding</code>, method substitution A person behaves differently as a student, friend, employee"},{"location":"concepts/oop/#difference-between-implements-and-extends","title":"\ud83d\udd04 Difference Between <code>implements</code> and <code>extends</code>","text":"Feature <code>extends</code> <code>implements</code> Purpose Class inheritance Interface implementation Relationship \"is-a\" (e.g., a Car is a Vehicle) \"can-do\" (e.g., a class can Fly) Multiple Inheritances Only one class can be extended. Multiple interfaces can be implemented. Implementation Inherits and potentially overrides methods. Must provide implementations for all interface methods. Example <code>class Dog extends Animal { ... }</code> <code>class Bird implements Flyable { ... }</code>"},{"location":"concepts/solid/","title":"SOLID Principles","text":"<p>The SOLID principles are five key design principles in object-oriented programming (OOP), introduced by Robert C. Martin (Uncle Bob). These principles help make software more maintainable, scalable, testable, and easier to understand.</p>"},{"location":"concepts/solid/#what-does-solid-stand-for","title":"\ud83e\uddf1 What does SOLID stand for?","text":"Principle Meaning S Single Responsibility Principle (SRP) O Open/Closed Principle (OCP) L Liskov Substitution Principle (LSP) I Interface Segregation Principle (ISP) D Dependency Inversion Principle (DIP)"},{"location":"concepts/solid/#summary","title":"\ud83d\udca1 Summary","text":"Principle Goal SRP One responsibility per class OCP Extend without modifying LSP Safe substitutions ISP Split big interfaces DIP Depend on abstractions"},{"location":"concepts/solid/#single-responsibility-principle-srp","title":"\ud83e\udde9 Single Responsibility Principle (SRP)","text":"<p>\u201cA class should have only one reason to change.\u201d</p> <p>\u2705 Good: Each class/module/function should do one thing only, and do it well.</p> <p>\u274c Bad: A class that reads a file, parses data, logs errors, and saves to a database \u2014 too many responsibilities.</p> <p>\u2728 Why it matters: - Easier to test - Smaller classes = easier to debug and reuse - Changes in one feature don\u2019t accidentally break others</p>"},{"location":"concepts/solid/#example-in-typescript","title":"Example in TypeScript:","text":"<p>Bad Example:</p> <pre><code>class Report {\n    generateReport(): void {\n        console.log(\"Generating report...\");\n    }\n\n    saveToFile(): void {\n        console.log(\"Saving report to file...\");\n    }\n\n    sendEmail(): void {\n        console.log(\"Sending report via email...\");\n    }\n}\n</code></pre> <p>Good Example:</p> <pre><code>class ReportGenerator {\n    generateReport(): string {\n        return \"Report content\";\n    }\n}\n\nclass FileSaver {\n    saveToFile(content: string): void {\n        console.log(\"Saving report to file...\");\n    }\n}\n\nclass EmailSender {\n    sendEmail(content: string): void {\n        console.log(\"Sending report via email...\");\n    }\n}\n</code></pre>"},{"location":"concepts/solid/#openclosed-principle-ocp","title":"\ud83d\udeaa Open/Closed Principle (OCP)","text":"<p>\u201cSoftware entities should be open for extension, but closed for modification.\u201d</p> <p>\u2705 Good: You can add new behavior without changing existing code.</p> <p>\u274c Bad: You keep editing an existing function/class every time requirements change.</p> <p>\ud83d\udee0 Example: Use inheritance, interfaces, or polymorphism so you can extend behavior without touching old code.</p>"},{"location":"concepts/solid/#example-in-typescript_1","title":"Example in TypeScript:","text":"<p>Bad Example:</p> <pre><code>class PaymentProcessor {\n    processPayment(paymentType: string): void {\n        if (paymentType === \"credit_card\") {\n            console.log(\"Processing credit card payment...\");\n        } else if (paymentType === \"paypal\") {\n            console.log(\"Processing PayPal payment...\");\n        }\n    }\n}\n</code></pre> <p>Good Example:</p> <pre><code>interface PaymentMethod {\n    process(): void;\n}\n\nclass CreditCardPayment implements PaymentMethod {\n    process(): void {\n        console.log(\"Processing credit card payment...\");\n    }\n}\n\nclass PayPalPayment implements PaymentMethod {\n    process(): void {\n        console.log(\"Processing PayPal payment...\");\n    }\n}\n\nclass PaymentProcessor {\n    processPayment(paymentMethod: PaymentMethod): void {\n        paymentMethod.process();\n    }\n}\n</code></pre>"},{"location":"concepts/solid/#liskov-substitution-principle-lsp","title":"\ud83e\uddec Liskov Substitution Principle (LSP)","text":"<p>\u201cObjects of a superclass should be replaceable with objects of subclasses without breaking functionality.\u201d</p> <p>\u2705 Good: If <code>Bird</code> has a method <code>fly()</code>, then <code>Penguin</code> shouldn\u2019t inherit from <code>Bird</code> unless it can logically fly.</p> <p>\u274c Bad: Subclass overrides behavior in a way that breaks expectations (e.g., throws <code>NotImplementedError</code>).</p> <p>\u2728 Why it matters: - Polymorphism only works if substitution is safe - Prevents runtime surprises</p>"},{"location":"concepts/solid/#example-in-typescript_2","title":"Example in TypeScript:","text":"<p>Bad Example:</p> <pre><code>class Bird {\n    fly(): void {\n        console.log(\"Flying...\");\n    }\n}\n\nclass Penguin extends Bird {\n    fly(): void {\n        throw new Error(\"Penguins can't fly!\");\n    }\n}\n</code></pre> <p>Good Example:</p> <pre><code>class Bird {}\n\nclass FlyingBird extends Bird {\n    fly(): void {\n        console.log(\"Flying...\");\n    }\n}\n\nclass Penguin extends Bird {\n    swim(): void {\n        console.log(\"Swimming...\");\n    }\n}\n</code></pre>"},{"location":"concepts/solid/#interface-segregation-principle-isp","title":"\ud83e\uddc3 Interface Segregation Principle (ISP)","text":"<p>\u201cClients should not be forced to depend on interfaces they do not use.\u201d</p> <p>\u2705 Good: Split large interfaces into smaller, focused ones.</p> <p>\u274c Bad: A class implementing an interface with 10 methods when it only needs 2.</p> <p>\u2728 Why it matters: - Prevents unnecessary implementation - Leads to more modular, adaptable design</p>"},{"location":"concepts/solid/#example-in-typescript_3","title":"Example in TypeScript:","text":"<p>Bad Example:</p> <pre><code>interface Animal {\n    fly(): void;\n    swim(): void;\n    run(): void;\n}\n\nclass Dog implements Animal {\n    fly(): void {\n        throw new Error(\"Dogs can't fly!\");\n    }\n\n    swim(): void {\n        console.log(\"Dog swimming...\");\n    }\n\n    run(): void {\n        console.log(\"Dog running...\");\n    }\n}\n</code></pre> <p>Good Example:</p> <pre><code>interface Swimmer {\n    swim(): void;\n}\n\ninterface Runner {\n    run(): void;\n}\n\nclass Dog implements Swimmer, Runner {\n    swim(): void {\n        console.log(\"Dog swimming...\");\n    }\n\n    run(): void {\n        console.log(\"Dog running...\");\n    }\n}\n</code></pre>"},{"location":"concepts/solid/#dependency-inversion-principle-dip","title":"\ud83d\udd0c Dependency Inversion Principle (DIP)","text":"<p>\u201cHigh-level modules should not depend on low-level modules. Both should depend on abstractions.\u201d</p> <p>\u2705 Good: Use interfaces or abstract classes for dependencies.</p> <p>\u274c Bad: A class directly instantiates or depends on specific low-level implementations.</p> <p>\u2728 Tools to help: - Dependency Injection frameworks - Inversion of Control (IoC) containers</p>"},{"location":"concepts/solid/#example-in-typescript_4","title":"Example in TypeScript:","text":"<p>Bad Example:</p> <pre><code>class MySQLDatabase {\n    connect(): void {\n        console.log(\"Connecting to MySQL...\");\n    }\n}\n\nclass UserService {\n    private db: MySQLDatabase;\n\n    constructor() {\n        this.db = new MySQLDatabase();\n    }\n\n    getUser(): void {\n        this.db.connect();\n        console.log(\"Fetching user...\");\n    }\n}\n</code></pre> <p>Good Example:</p> <pre><code>interface Database {\n    connect(): void;\n}\n\nclass MySQLDatabase implements Database {\n    connect(): void {\n        console.log(\"Connecting to MySQL...\");\n    }\n}\n\nclass UserService {\n    private db: Database;\n\n    constructor(db: Database) {\n        this.db = db;\n    }\n\n    getUser(): void {\n        this.db.connect();\n        console.log(\"Fetching user...\");\n    }\n}\n\n// Usage\nconst mySQL = new MySQLDatabase();\nconst userService = new UserService(mySQL);\nuserService.getUser();\n</code></pre>"},{"location":"devops/k8s/basics/","title":"\ud83e\udded What is Kubernetes?","text":"<p>Kubernetes (also called k8s) is an open-source platform to automate deploying, scaling, and managing containerized applications. Think of it like an operating system for your data center.</p> <p>Imagine you have 100 containers running your app. Kubernetes helps you:</p> <ul> <li>Start them on different machines (nodes)</li> <li>Keep them alive (self-healing)</li> <li>Scale them up or down automatically</li> <li>Handle traffic</li> <li>Store persistent data</li> </ul> <p>Kubernetes abstracts away the underlying machines and gives you a clean, declarative way to run apps.</p>"},{"location":"devops/k8s/basics/#1-core-concepts","title":"\ud83e\uddf1 1. Core Concepts","text":""},{"location":"devops/k8s/basics/#cluster","title":"Cluster","text":"<ul> <li>A Cluster is a group of machines (nodes) running containers.</li> <li>It consists of a Control Plane (manages the cluster) and Nodes (run workloads).</li> </ul>"},{"location":"devops/k8s/basics/#node","title":"Node","text":"<ul> <li>A Node is a physical or virtual machine in the cluster.</li> <li>It provides the resources (CPU, memory, storage) needed to run applications.</li> <li>Each node runs:<ul> <li>Kubelet: Ensures containers are running in pods.</li> <li>Kube-proxy: Manages networking for pods.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#pod","title":"Pod","text":"<ul> <li>A Pod is the smallest deployable unit in Kubernetes.</li> <li>It represents one or more containers that share:<ul> <li>Network namespace (IP address).</li> <li>Storage volumes.</li> </ul> </li> <li>Pods are ephemeral and are managed by higher-level controllers like Deployments.</li> </ul>"},{"location":"devops/k8s/basics/#deployment","title":"Deployment","text":"<ul> <li>A Deployment ensures that the desired number of pod replicas are running.</li> <li>It manages updates to pods and their underlying containers.</li> <li>Example use case: Rolling updates to deploy a new version of an application.</li> </ul>"},{"location":"devops/k8s/basics/#service","title":"Service","text":"<ul> <li>A Service provides a stable network endpoint to access pods.</li> <li>It abstracts the dynamic nature of pods and offers:<ul> <li>ClusterIP: Internal communication within the cluster.</li> <li>NodePort: Exposes the service on a specific port of each node.</li> <li>LoadBalancer: Exposes the service externally using a cloud provider's load balancer.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#configmap-secret","title":"ConfigMap &amp; Secret","text":"<ul> <li>ConfigMap: Injects configuration data (non-sensitive) into pods.</li> <li>Secret: Injects sensitive data (e.g., passwords, API keys) into pods securely.</li> </ul>"},{"location":"devops/k8s/basics/#volume","title":"Volume","text":"<ul> <li>A Volume is a storage resource attached to a pod.</li> <li>It persists data beyond the lifecycle of a container but not beyond the lifecycle of the pod.</li> </ul>"},{"location":"devops/k8s/basics/#namespace","title":"Namespace","text":"<ul> <li>A Namespace is a virtual cluster within a physical cluster.</li> <li>It is used for organizing resources and enabling multi-tenancy.</li> </ul>"},{"location":"devops/k8s/basics/#replicaset","title":"ReplicaSet","text":"<ul> <li>A ReplicaSet ensures a specified number of pod replicas are running at all times.</li> <li>It is typically managed by a Deployment.</li> </ul>"},{"location":"devops/k8s/basics/#statefulset","title":"StatefulSet","text":"<ul> <li>A StatefulSet is used for stateful applications (e.g., databases).</li> <li>It provides stable network identities and persistent storage for each pod.</li> </ul>"},{"location":"devops/k8s/basics/#daemonset","title":"DaemonSet","text":"<ul> <li>A DaemonSet ensures that a copy of a pod runs on all (or specific) nodes.</li> <li>Example use case: Running log collection or monitoring agents on every node.</li> </ul>"},{"location":"devops/k8s/basics/#job","title":"Job","text":"<ul> <li>A Job runs a pod to completion.</li> <li>It is used for batch processing tasks.</li> </ul>"},{"location":"devops/k8s/basics/#cronjob","title":"CronJob","text":"<ul> <li>A CronJob schedules jobs to run at specific times or intervals.</li> <li>Example use case: Running a backup script every night.</li> </ul>"},{"location":"devops/k8s/basics/#horizontal-pod-autoscaler","title":"Horizontal Pod Autoscaler","text":"<ul> <li>Automatically scales the number of pods based on CPU/memory usage or custom metrics.</li> </ul>"},{"location":"devops/k8s/basics/#custom-resource-definitions-crds","title":"Custom Resource Definitions (CRDs)","text":"<ul> <li>CRDs allow you to define your own resource types in Kubernetes.</li> <li>They extend Kubernetes' functionality to manage custom applications.</li> </ul>"},{"location":"devops/k8s/basics/#kubelet","title":"Kubelet","text":"<ul> <li>A Kubelet is an agent that runs on each node.</li> <li>It ensures that containers are running in pods as specified by the Control Plane.</li> </ul>"},{"location":"devops/k8s/basics/#kube-proxy","title":"Kube-proxy","text":"<ul> <li>Kube-proxy manages network rules on nodes to allow communication between pods and services.</li> </ul>"},{"location":"devops/k8s/basics/#control-plane","title":"Control Plane","text":"<ul> <li>The Control Plane is the brain of the cluster.</li> <li>It manages the state of the cluster and schedules workloads.</li> <li>Key components:<ul> <li>API Server: Exposes the Kubernetes API.</li> <li>etcd: Stores cluster state and configuration.</li> <li>Scheduler: Assigns pods to nodes.</li> <li>Controller Manager: Ensures the desired state of the cluster.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#etcd","title":"etcd","text":"<ul> <li>A distributed key-value store used to store all cluster data.</li> <li>It is the source of truth for the cluster's state.</li> </ul>"},{"location":"devops/k8s/basics/#scheduler","title":"Scheduler","text":"<ul> <li>The Scheduler assigns pods to nodes based on resource availability and constraints.</li> </ul>"},{"location":"devops/k8s/basics/#controller-manager","title":"Controller Manager","text":"<ul> <li>The Controller Manager runs controllers that regulate the state of the cluster.</li> <li>Example controllers:<ul> <li>Node Controller: Monitors node health.</li> <li>Replication Controller: Ensures the desired number of pod replicas.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#admission-controller","title":"Admission Controller","text":"<ul> <li>Validates and modifies requests to the API server before they are persisted in etcd.</li> </ul>"},{"location":"devops/k8s/basics/#network-policy","title":"Network Policy","text":"<ul> <li>A Network Policy controls the communication between pods.</li> <li>It defines rules for ingress and egress traffic.</li> </ul>"},{"location":"devops/k8s/basics/#resource-quotas","title":"Resource Quotas","text":"<ul> <li>Resource Quotas limit the amount of resources (CPU, memory) a namespace can use.</li> </ul>"},{"location":"devops/k8s/basics/#limitrange","title":"LimitRange","text":"<ul> <li>A LimitRange sets default resource requests and limits for containers in a namespace.</li> </ul>"},{"location":"devops/k8s/basics/#pod-security-policies","title":"Pod Security Policies","text":"<ul> <li>Pod Security Policies control security settings for pods, such as:<ul> <li>Privileged access.</li> <li>Host network usage.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#serviceaccount","title":"ServiceAccount","text":"<ul> <li>A ServiceAccount provides an identity for processes running in a pod to interact with the Kubernetes API.</li> </ul>"},{"location":"devops/k8s/basics/#rbac-role-based-access-control","title":"RBAC (Role-Based Access Control)","text":"<ul> <li>RBAC manages permissions for users and service accounts.</li> <li>It defines roles and role bindings to control access to resources.</li> </ul>"},{"location":"devops/k8s/basics/#network-plugins","title":"Network Plugins","text":"<ul> <li>Network Plugins extend Kubernetes networking capabilities using the Container Network Interface (CNI).</li> </ul>"},{"location":"devops/k8s/basics/#2-storage-persistence","title":"\ud83d\udcbe 2. Storage &amp; Persistence","text":""},{"location":"devops/k8s/basics/#persistentvolume-pv","title":"PersistentVolume (PV)","text":"<ul> <li>A PersistentVolume is a piece of cluster storage provisioned by an administrator or dynamically.</li> </ul>"},{"location":"devops/k8s/basics/#persistentvolumeclaim-pvc","title":"PersistentVolumeClaim (PVC)","text":"<ul> <li>A PersistentVolumeClaim is a request for storage by a pod.</li> </ul>"},{"location":"devops/k8s/basics/#storageclass","title":"StorageClass","text":"<ul> <li>A StorageClass defines how storage is provisioned dynamically.</li> </ul>"},{"location":"devops/k8s/basics/#3-advanced-workloads","title":"\ud83d\udce6 3. Advanced Workloads","text":""},{"location":"devops/k8s/basics/#statefulsets","title":"StatefulSets","text":"<ul> <li>For stateful apps (like databases), gives stable network &amp; storage.</li> </ul>"},{"location":"devops/k8s/basics/#daemonsets","title":"DaemonSets","text":"<ul> <li>Run one pod per node (e.g., for log collection).</li> </ul>"},{"location":"devops/k8s/basics/#jobs-cronjobs","title":"Jobs &amp; CronJobs","text":"<ul> <li>For batch processing or scheduled tasks.</li> </ul>"},{"location":"devops/k8s/basics/#init-containers","title":"Init Containers","text":"<ul> <li>Run before the main container starts.</li> </ul>"},{"location":"devops/k8s/basics/#4-extending-kubernetes","title":"\ud83d\udd0c 4. Extending Kubernetes","text":""},{"location":"devops/k8s/basics/#custom-resources-crds","title":"Custom Resources (CRDs)","text":"<ul> <li>Add new object types to the cluster.</li> </ul>"},{"location":"devops/k8s/basics/#operators","title":"Operators","text":"<ul> <li>Controllers that manage complex apps using CRDs.</li> </ul>"},{"location":"devops/k8s/basics/#admission-controllers","title":"Admission Controllers","text":"<ul> <li>Hook into request lifecycle to validate/mutate requests.</li> </ul>"},{"location":"devops/k8s/basics/#5-configuration-packaging","title":"\ud83c\udf9b\ufe0f 5. Configuration &amp; Packaging","text":""},{"location":"devops/k8s/basics/#helm","title":"Helm","text":"<ul> <li>The package manager for Kubernetes.<ul> <li>Helm Chart: A templated set of YAMLs that define a k8s app.</li> <li>Great for reusability and sharing configurations.</li> </ul> </li> </ul>"},{"location":"devops/k8s/basics/#kustomize","title":"Kustomize","text":"<ul> <li>Built-in tool for customizing YAML configurations.</li> </ul>"},{"location":"devops/k8s/basics/#6-security-access","title":"\ud83d\udd12 6. Security &amp; Access","text":""},{"location":"devops/k8s/basics/#rbac","title":"RBAC","text":"<ul> <li>Role-Based Access Control.</li> </ul>"},{"location":"devops/k8s/basics/#serviceaccounts","title":"ServiceAccounts","text":"<ul> <li>Access identity for pods.</li> </ul>"},{"location":"devops/k8s/basics/#network-policies","title":"Network Policies","text":"<ul> <li>Control pod-to-pod communication.</li> </ul>"},{"location":"devops/k8s/basics/#7-observability","title":"\ud83d\udcc8 7. Observability","text":""},{"location":"devops/k8s/basics/#logs","title":"Logs","text":"<ul> <li><code>kubectl logs</code>, or tools like Fluentd, Loki.</li> </ul>"},{"location":"devops/k8s/basics/#metrics","title":"Metrics","text":"<ul> <li>Prometheus, Grafana.</li> </ul>"},{"location":"devops/k8s/basics/#tracing","title":"Tracing","text":"<ul> <li>Jaeger, OpenTelemetry.</li> </ul>"},{"location":"devops/k8s/basics/#probes","title":"Probes","text":"<ul> <li>Liveness and readiness checks.</li> </ul>"},{"location":"devops/k8s/basics/#8-cicd-gitops","title":"\u2699\ufe0f 8. CI/CD &amp; GitOps","text":""},{"location":"devops/k8s/basics/#argocd-flux","title":"ArgoCD / Flux","text":"<ul> <li>GitOps deployment tools.</li> </ul>"},{"location":"devops/k8s/basics/#jenkins-github-actions-kubectl","title":"Jenkins / GitHub Actions + kubectl","text":"<ul> <li>Push apps to k8s.</li> </ul>"},{"location":"devops/k8s/basics/#secrets-management","title":"Secrets Management","text":"<ul> <li>Use sealed-secrets, external-secrets, etc.</li> </ul>"},{"location":"devops/k8s/basics/#9-cloud-native-ecosystem","title":"\u2601\ufe0f 9. Cloud-Native Ecosystem","text":""},{"location":"devops/k8s/basics/#ingress-controllers","title":"Ingress Controllers","text":"<ul> <li>NGINX, Traefik, or cloud-specific ones.</li> </ul>"},{"location":"devops/k8s/basics/#service-mesh","title":"Service Mesh","text":"<ul> <li>A dedicated infrastructure layer for managing service-to-service communication.</li> <li>Features:<ul> <li>Traffic management (routing, load balancing).</li> <li>Observability (metrics, logs, tracing).</li> <li>Security (mTLS).</li> </ul> </li> <li>Examples: Istio, Linkerd.</li> </ul>"},{"location":"devops/k8s/basics/#container-runtimes","title":"Container Runtimes","text":"<ul> <li>containerd, CRI-O.</li> </ul>"},{"location":"devops/k8s/basics/#recommended-learning-order","title":"\ud83d\udcd8 Recommended Learning Order","text":"<ol> <li>Pods, Deployments, Services \u2705</li> <li>ConfigMaps, Secrets, Volumes</li> <li>PVCs &amp; StorageClass</li> <li>Helm charts</li> <li>CRDs &amp; Operators</li> <li>Monitoring &amp; Probes</li> <li>Security basics (RBAC, NetworkPolicy)</li> <li>GitOps or Helm-based CI/CD</li> <li>Advanced topics (Service Mesh, Ingress Controllers)</li> <li>Cloud-native tools (Fluentd, Prometheus, Grafana)</li> <li>Explore the Kubernetes ecosystem (Istio, ArgoCD, etc.)</li> </ol>"},{"location":"devops/k8s/crd/","title":"\ud83d\udee0\ufe0f Custom Resources (CRD) &amp; Operators","text":""},{"location":"devops/k8s/crd/#what-are-crds-and-operators","title":"\ud83e\udde0 What are CRDs and Operators?","text":"<p>Kubernetes comes with built-in resource types like Pods, Services, and Deployments. Custom Resource Definitions (CRDs) allow you to extend Kubernetes by defining your own resource types. Operators are controllers that watch these custom resources and automate their management.</p>"},{"location":"devops/k8s/crd/#analogy","title":"\ud83e\udde0 Analogy:","text":"<ul> <li>Kubernetes understands built-in resources like Pods and Services. A CRD teaches Kubernetes to understand new resource types, like <code>KafkaCluster</code> or <code>RedisFailover</code>.</li> <li>An Operator is like a robot that watches these custom resources and takes actions to manage them.</li> </ul>"},{"location":"devops/k8s/crd/#why-use-crds-and-operators","title":"\ud83c\udfaf Why Use CRDs and Operators?","text":"<ol> <li> <p>Extend Kubernetes:</p> <ul> <li>CRDs let you define custom resource types tailored to your application needs.</li> </ul> </li> <li> <p>Automate Complex Workflows:</p> <ul> <li>Operators automate the management of custom resources, such as scaling, backups, and failovers.</li> </ul> </li> <li> <p>Declarative Management:</p> <ul> <li>CRDs and Operators enable declarative management of complex applications, just like Kubernetes manages Pods and Deployments.</li> </ul> </li> <li> <p>Reusable Patterns:</p> <ul> <li>CRDs and Operators provide reusable patterns for managing stateful applications like databases, message queues, and more.</li> </ul> </li> </ol>"},{"location":"devops/k8s/crd/#key-concepts","title":"\ud83d\udd11 Key Concepts","text":"<ol> <li> <p>Custom Resource Definition (CRD):</p> <ul> <li>A CRD is a YAML file that defines a new resource type in Kubernetes.</li> <li>Example: Defining a <code>KafkaCluster</code> resource.</li> </ul> </li> <li> <p>Custom Resource (CR):</p> <ul> <li>A CR is an instance of a CRD, just like a Pod is an instance of a Deployment.</li> </ul> </li> <li> <p>Operator:</p> <ul> <li>An Operator is a controller that watches custom resources and automates their management.</li> </ul> </li> </ol>"},{"location":"devops/k8s/crd/#example-defining-a-crd","title":"\ud83d\udd27 Example: Defining a CRD","text":"<p>Here\u2019s an example of a CRD that defines a <code>MyApp</code> resource:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: myapps.example.com\nspec:\n  group: example.com\n  names:\n    kind: MyApp\n    listKind: MyAppList\n    plural: myapps\n    singular: myapp\n  scope: Namespaced\n  versions:\n    - name: v1\n      served: true\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                replicas:\n                  type: integer\n                image:\n                  type: string\n</code></pre>"},{"location":"devops/k8s/crd/#explanation","title":"Explanation:","text":"<ul> <li>group: The API group for the resource (e.g., <code>example.com</code>).</li> <li>names: Defines the resource name (<code>myapps</code>) and kind (<code>MyApp</code>).</li> <li>scope: Specifies whether the resource is <code>Namespaced</code> or <code>Cluster</code> scoped.</li> <li>versions: Lists the supported API versions.</li> <li>schema: Defines the structure of the resource using OpenAPI v3.</li> </ul>"},{"location":"devops/k8s/crd/#example-creating-a-custom-resource-cr","title":"\ud83d\udd27 Example: Creating a Custom Resource (CR)","text":"<p>Here\u2019s an example of a <code>MyApp</code> custom resource:</p> <pre><code>apiVersion: example.com/v1\nkind: MyApp\nmetadata:\n  name: my-app-instance\nspec:\n  replicas: 3\n  image: nginx:latest\n</code></pre>"},{"location":"devops/k8s/crd/#explanation_1","title":"Explanation:","text":"<ul> <li>apiVersion: Matches the group and version defined in the CRD.</li> <li>kind: Matches the kind defined in the CRD (<code>MyApp</code>).</li> <li>spec: Contains the custom configuration for the resource.</li> </ul>"},{"location":"devops/k8s/crd/#example-commands","title":"\ud83d\udd27 Example Commands","text":"<ol> <li> <p>Apply a CRD:     <code>kubectl apply -f myapp-crd.yaml</code></p> </li> <li> <p>Create a Custom Resource:     <code>kubectl apply -f myapp-cr.yaml</code></p> </li> <li> <p>List Custom Resources:     <code>kubectl get myapps</code></p> </li> <li> <p>Describe a Custom Resource:     <code>kubectl describe myapp my-app-instance</code></p> </li> <li> <p>Delete a Custom Resource:     <code>kubectl delete myapp my-app-instance</code></p> </li> <li> <p>Delete a CRD:     <code>kubectl delete crd myapps.example.com</code></p> </li> </ol>"},{"location":"devops/k8s/crd/#best-practices","title":"\ud83c\udf1f Best Practices","text":"<ol> <li> <p>Use OpenAPI Validation:</p> <ul> <li>Define schemas in your CRD to validate custom resources.</li> </ul> </li> <li> <p>Namespace Your CRDs:</p> <ul> <li>Use a unique API group (e.g., <code>example.com</code>) to avoid conflicts with other CRDs.</li> </ul> </li> <li> <p>Leverage Operators:</p> <ul> <li>Use Operators to automate the management of custom resources.</li> </ul> </li> <li> <p>Monitor Custom Resources:</p> <ul> <li>Use tools like Prometheus and Grafana to monitor the health and performance of custom resources.</li> </ul> </li> <li> <p>Version Your CRDs:</p> <ul> <li>Support multiple versions of your CRD to ensure backward compatibility.</li> </ul> </li> </ol>"},{"location":"devops/k8s/crd/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li> <p>Popular Operators:</p> <ul> <li>cert-manager: Manages TLS certificates using CRDs like <code>Certificate</code>.</li> <li>Prometheus Operator: Manages Prometheus instances using CRDs like <code>Prometheus</code> and <code>Alertmanager</code>.</li> </ul> </li> <li> <p>CRD Lifecycle:</p> <ul> <li>CRDs are cluster-scoped resources. Deleting a CRD will delete all associated custom resources.</li> </ul> </li> <li> <p>Debugging:</p> <ul> <li>Use <code>kubectl get events</code> to debug issues with CRDs or custom resources.</li> </ul> </li> </ul>"},{"location":"devops/k8s/deployment/","title":"\ud83c\udfd7\ufe0f Deployments \u2013 How You Manage Pods","text":""},{"location":"devops/k8s/deployment/#what-is-a-deployment","title":"\ud83e\udde0 What is a Deployment?","text":"<p>A Deployment is a Kubernetes resource that manages a set of pods. It ensures that a specified number of pod replicas are running at all times and provides features like self-healing, rolling updates, and scaling.</p>"},{"location":"devops/k8s/deployment/#analogy","title":"Analogy:","text":"<p>A Deployment is like a factory manager \u2014 it keeps a fixed number of pods running and replaces them if they fail. You don\u2019t run pods directly in most real-world setups. Instead, you use a Deployment, which says:  </p> <p>\u201cHey Kubernetes, always keep 3 copies of this pod running.\u201d</p>"},{"location":"devops/k8s/deployment/#benefits-of-deployments","title":"\ud83e\udde0 Benefits of Deployments","text":"<ol> <li> <p>Self-Healing:</p> <ul> <li>If a pod crashes or is deleted, the Deployment automatically creates a new one to maintain the desired state.</li> </ul> </li> <li> <p>Rolling Updates:</p> <ul> <li>Deployments allow you to update your application with zero downtime by gradually replacing old pods with new ones.</li> </ul> </li> <li> <p>Easy Scaling:</p> <ul> <li>You can scale the number of pods up or down easily using the <code>kubectl scale</code> command.</li> </ul> </li> <li> <p>Declarative Management:</p> <ul> <li>You define the desired state of your application in a YAML file, and Kubernetes ensures that the actual state matches it.</li> </ul> </li> </ol>"},{"location":"devops/k8s/deployment/#yaml-example-basic-deployment","title":"\ud83d\udd27 YAML Example: Basic Deployment","text":"<p>Here\u2019s an example of a Deployment YAML file:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n        - name: app\n          image: my-app-image:latest\n</code></pre>"},{"location":"devops/k8s/deployment/#explanation","title":"Explanation:","text":"<ul> <li>apiVersion: Specifies the API version (<code>apps/v1</code> is used for Deployments).</li> <li>kind: Defines the resource type (<code>Deployment</code>).</li> <li>metadata: Contains metadata like the name of the Deployment.</li> <li>spec: Specifies the desired state of the Deployment.</li> <li>replicas: Number of pod replicas to maintain.</li> <li>selector: Defines how to identify pods managed by this Deployment (using labels).</li> <li>template: Specifies the pod template to use for creating pods.<ul> <li>metadata: Labels for the pods.</li> <li>spec: Defines the containers in the pod.</li> <li>name: Name of the container.</li> <li>image: The container image to use.</li> </ul> </li> </ul>"},{"location":"devops/k8s/deployment/#deployment-lifecycle","title":"\ud83d\udd04 Deployment Lifecycle","text":"<p>Deployments go through the following lifecycle:</p> <ol> <li> <p>Creation:</p> <ul> <li>When you create a Deployment, Kubernetes creates the specified number of pods.</li> </ul> </li> <li> <p>Scaling:</p> <ul> <li>You can scale the Deployment up or down by changing the <code>replicas</code> field.</li> </ul> </li> <li> <p>Updating:</p> <ul> <li>When you update the Deployment (e.g., change the container image), Kubernetes performs a rolling update.</li> </ul> </li> <li> <p>Deletion:</p> <ul> <li>When you delete a Deployment, Kubernetes deletes all the pods it manages.</li> </ul> </li> </ol>"},{"location":"devops/k8s/deployment/#yaml-example-rolling-update-strategy","title":"\ud83d\udd27 YAML Example: Rolling Update Strategy","text":"<p>Here\u2019s an example of a Deployment with a rolling update strategy:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: rolling-update-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-app\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 1\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n        - name: app\n          image: my-app-image:v2\n</code></pre>"},{"location":"devops/k8s/deployment/#explanation_1","title":"Explanation:","text":"<ul> <li>strategy: Defines the update strategy.</li> <li>type: Specifies the strategy type (<code>RollingUpdate</code> is the default).</li> <li>rollingUpdate:<ul> <li>maxUnavailable: Maximum number of pods that can be unavailable during the update.</li> <li>maxSurge: Maximum number of extra pods that can be created during the update.</li> </ul> </li> </ul>"},{"location":"devops/k8s/deployment/#common-commands-for-deployments","title":"\ud83d\udee0\ufe0f Common Commands for Deployments","text":"<ol> <li> <p>Create a Deployment: <code>kubectl apply -f deployment.yaml</code></p> </li> <li> <p>View Deployments: <code>kubectl get deployments</code></p> </li> <li> <p>Scale a Deployment: <code>kubectl scale deployment my-deployment --replicas=5</code></p> </li> <li> <p>Update a Deployment: <code>kubectl set image deployment/my-deployment app=my-app-image:v2</code></p> </li> <li> <p>Delete a Deployment: <code>kubectl delete deployment my-deployment</code></p> </li> </ol>"},{"location":"devops/k8s/deployment/#best-practices-for-deployments","title":"\ud83d\udee1\ufe0f Best Practices for Deployments","text":"<ol> <li> <p>Use Labels and Selectors:</p> <ul> <li>Use meaningful labels to identify and manage your pods effectively.</li> </ul> </li> <li> <p>Set Resource Limits:</p> <ul> <li>Define CPU and memory limits for your containers to prevent resource contention.</li> </ul> </li> <li> <p>Monitor Deployment Health:</p> <ul> <li>Use readiness and liveness probes to monitor the health of your pods.</li> </ul> </li> <li> <p>Rollback on Failure:</p> <ul> <li>Kubernetes automatically supports rollbacks if a rolling update fails.</li> </ul> </li> <li> <p>Test Updates in Staging:</p> <ul> <li>Always test your updates in a staging environment before deploying to production.</li> </ul> </li> </ol>"},{"location":"devops/k8s/deployment/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li>ReplicaSet: Deployments manage ReplicaSets, which in turn manage pods. You usually don\u2019t interact with ReplicaSets directly.</li> <li>Rollback: If an update fails, you can rollback to a previous version using: <code>kubectl rollout undo deployment my-deployment</code></li> <li>Status Check: Check the status of a Deployment using: <code>kubectl rollout status deployment my-deployment</code></li> </ul>"},{"location":"devops/k8s/faq/","title":"Kubernetes FAQ","text":""},{"location":"devops/k8s/faq/#q1-if-i-have-5-microservices-that-are-part-of-a-single-application-will-they-run-in-the-same-cluster-on-the-same-node-or-somewhere-else-should-i-manage-all-5-microservices-in-a-single-deployment","title":"Q1. If I have 5 microservices that are part of a single application, will they run in the same cluster, on the same node, or somewhere else? Should I manage all 5 microservices in a single Deployment?","text":"<p>Answer: - Same Cluster: Yes, all 5 microservices can run in the same Kubernetes cluster. A cluster is a logical grouping of nodes where Kubernetes schedules and runs workloads. Microservices in the same cluster can communicate with each other using Kubernetes Services.</p> <ul> <li> <p>Same Node: Not necessarily. Kubernetes schedules pods across nodes in the cluster based on resource availability and constraints. Some microservices may run on the same node, while others may run on different nodes. Kubernetes ensures optimal resource utilization and high availability.</p> </li> <li> <p>Single Deployment: No, you should not manage all 5 microservices in a single Deployment. Each microservice should have its own Deployment. This allows you to:</p> </li> <li>Scale each microservice independently.</li> <li>Update each microservice independently.</li> <li>Monitor and manage the lifecycle of each microservice separately.</li> <li>Ensure fault isolation (issues in one microservice won't affect others).</li> </ul>"},{"location":"devops/k8s/faq/#recommended-setup","title":"Recommended Setup:","text":"<ol> <li>Separate Deployments: Create a separate Deployment for each microservice. Each Deployment will manage its own pods.</li> <li>Communication: Use Kubernetes Services to enable communication between microservices.</li> <li>Scaling: Scale each Deployment independently based on the resource and traffic requirements of each microservice.</li> </ol>"},{"location":"devops/k8s/faq/#example","title":"Example:","text":"<p>If you have 5 microservices (<code>service1</code>, <code>service2</code>, ..., <code>service5</code>), you would create 5 separate Deployments, one for each microservice. For example:</p>"},{"location":"devops/k8s/faq/#deployment-for-service1","title":"Deployment for <code>service1</code>:","text":"<pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: service1-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: service1\n  template:\n    metadata:\n      labels:\n        app: service1\n    spec:\n      containers:\n        - name: service1-container\n          image: service1-image:latest\n</code></pre>"},{"location":"devops/k8s/faq/#service-for-service1","title":"Service for <code>service1</code>:","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: service1\nspec:\n  selector:\n    app: service1\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP\n</code></pre> <p>\"Repeat this pattern for the other microservices (service2, service3, etc.)\". Meaning for each additional microservice in your application (e.g., service2, service3, etc.), you should create a similar Deployment and Service configuration as shown in the example for service1.</p>"},{"location":"devops/k8s/faq/#summary","title":"Summary:","text":"<ul> <li>All microservices can run in the same cluster.</li> <li>Kubernetes will schedule the pods across nodes in the cluster based on resource availability.</li> <li>Each microservice should have its own Deployment and pods.</li> <li>Use Services to enable communication between microservices.</li> </ul>"},{"location":"devops/k8s/faq/#q2-what-is-the-difference-between-a-pod-and-a-deployment-in-kubernetes","title":"Q2. What is the difference between a Pod and a Deployment in Kubernetes?","text":"<p>Answer: - A Pod is the smallest deployable unit in Kubernetes, which can contain one or more containers. - A Deployment is a higher-level abstraction that manages pods. It ensures the desired number of pod replicas are running, handles rolling updates, and provides self-healing capabilities.</p>"},{"location":"devops/k8s/faq/#q3-how-do-microservices-communicate-with-each-other-in-kubernetes","title":"Q3. How do microservices communicate with each other in Kubernetes?","text":"<p>Answer: - Microservices communicate using Services in Kubernetes. A Service provides a stable network endpoint for a set of pods and enables communication between microservices using DNS names (e.g., <code>http://service-name</code>).</p>"},{"location":"devops/k8s/faq/#q4-can-i-run-multiple-containers-in-a-single-pod","title":"Q4. Can I run multiple containers in a single Pod?","text":"<p>Answer: - Yes, a Pod can contain multiple containers, but they are tightly coupled and share the same network namespace and storage. This is typically used for sidecar containers (e.g., logging or monitoring).</p>"},{"location":"devops/k8s/faq/#q5-how-does-kubernetes-handle-scaling-for-microservices","title":"Q5. How does Kubernetes handle scaling for microservices?","text":"<p>Answer: - Kubernetes allows you to scale microservices by increasing or decreasing the number of pod replicas in a Deployment. You can scale manually using the <code>kubectl scale</code> command or automatically using the Horizontal Pod Autoscaler (HPA).</p>"},{"location":"devops/k8s/faq/#q6-what-happens-if-a-pod-crashes-in-kubernetes","title":"Q6. What happens if a Pod crashes in Kubernetes?","text":"<p>Answer: - If a Pod crashes, Kubernetes automatically replaces it with a new Pod to maintain the desired state defined in the Deployment. This self-healing capability ensures high availability.</p>"},{"location":"devops/k8s/faq/#q7-how-do-i-update-a-microservice-in-kubernetes-without-downtime","title":"Q7. How do I update a microservice in Kubernetes without downtime?","text":"<p>Answer: - You can perform a rolling update using a Deployment. Kubernetes gradually replaces old pods with new ones, ensuring zero downtime during the update process.</p>"},{"location":"devops/k8s/helm/","title":"\ud83d\udce6 Helm &amp; Helm Charts \u2013 Packaging Kubernetes Apps","text":""},{"location":"devops/k8s/helm/#what-is-helm","title":"\ud83e\udde0 What is Helm?","text":"<p>Helm is a package manager for Kubernetes. It simplifies the deployment and management of Kubernetes applications by using Helm Charts, which are reusable, versioned templates for Kubernetes resources.</p>"},{"location":"devops/k8s/helm/#analogy","title":"\ud83e\udde0 Analogy:","text":"<ul> <li>Helm is like apt, yum, or npm \u2014 but for Kubernetes.</li> <li>Writing long YAML files for Kubernetes resources is tedious. Helm lets you define a Kubernetes app as a chart \u2014 a folder with templates and values. You can share, install, and upgrade charts like packages.</li> </ul>"},{"location":"devops/k8s/helm/#why-use-helm","title":"\ud83c\udfaf Why Use Helm?","text":"<ol> <li> <p>Simplifies Deployments:</p> <ul> <li>Helm reduces the complexity of managing Kubernetes resources by bundling them into a single chart.</li> </ul> </li> <li> <p>Supports Templating:</p> <ul> <li>Helm charts use templates, allowing you to define reusable and parameterized configurations.</li> </ul> </li> <li> <p>Enables Versioning and Rollback:</p> <ul> <li>Helm tracks the history of releases, making it easy to roll back to a previous version.</li> </ul> </li> <li> <p>Works Well with CI/CD and GitOps:</p> <ul> <li>Helm integrates seamlessly with CI/CD pipelines and GitOps workflows.</li> </ul> </li> </ol>"},{"location":"devops/k8s/helm/#key-concepts","title":"\ud83d\udd11 Key Concepts","text":"<ol> <li> <p>Chart:</p> <ul> <li>A Helm chart is a collection of files that describe a Kubernetes application.</li> <li>It includes templates, default values, and metadata.</li> </ul> </li> <li> <p>Release:</p> <ul> <li>A release is a specific instance of a Helm chart deployed to a Kubernetes cluster.</li> </ul> </li> <li> <p>Values:</p> <ul> <li>Values are configuration parameters that can be customized for each release.</li> </ul> </li> <li> <p>Repository:</p> <ul> <li>A Helm repository is a collection of charts that can be shared and downloaded.</li> </ul> </li> </ol>"},{"location":"devops/k8s/helm/#example-helm-chart-structure","title":"\ud83d\udd27 Example: Helm Chart Structure","text":"<p>Here\u2019s the structure of a typical Helm chart:</p> <pre><code>my-chart/\n\u251c\u2500\u2500 Chart.yaml          # Metadata about the chart\n\u251c\u2500\u2500 values.yaml         # Default configuration values\n\u251c\u2500\u2500 templates/          # Kubernetes resource templates\n\u2502   \u251c\u2500\u2500 deployment.yaml\n\u2502   \u251c\u2500\u2500 service.yaml\n\u2502   \u2514\u2500\u2500 ingress.yaml\n\u2514\u2500\u2500 charts/             # Dependencies (other charts)\n</code></pre>"},{"location":"devops/k8s/helm/#explanation","title":"Explanation:","text":"<ul> <li>Chart.yaml: Contains metadata about the chart (e.g., name, version).</li> <li>values.yaml: Defines default values for the chart.</li> <li>templates/: Contains Kubernetes resource templates (e.g., Deployment, Service).</li> <li>charts/: Stores dependencies (other charts).</li> </ul>"},{"location":"devops/k8s/helm/#example-commands","title":"\ud83d\udd27 Example Commands","text":"<ol> <li> <p>Install a Chart: <code>helm install my-app ./my-chart</code>    Installs the chart <code>my-chart</code> with the release name <code>my-app</code>.</p> </li> <li> <p>List Installed Releases: <code>helm list</code></p> </li> <li> <p>Upgrade a Release: <code>helm upgrade my-app ./my-chart</code></p> </li> <li> <p>Rollback a Release: <code>helm rollback my-app 1</code>    Rolls back the release <code>my-app</code> to revision <code>1</code>.</p> </li> <li> <p>Uninstall a Release: <code>helm uninstall my-app</code></p> </li> <li> <p>Search for Charts: <code>helm search hub nginx</code>    Searches for <code>nginx</code> charts in the Helm Hub.</p> </li> <li> <p>View Release History: <code>helm history my-app</code></p> </li> </ol>"},{"location":"devops/k8s/helm/#example-using-helm-values","title":"\ud83d\udd27 Example: Using Helm Values","text":"<p>You can override default values in <code>values.yaml</code> using the <code>--set</code> flag or a custom <code>values</code> file.</p>"},{"location":"devops/k8s/helm/#example-command","title":"Example Command:","text":"<p><code>helm install my-app ./my-chart --set replicaCount=3</code></p>"},{"location":"devops/k8s/helm/#example-valuesyaml","title":"Example <code>values.yaml</code>:","text":"<pre><code>replicaCount: 2\nimage:\n  repository: nginx\n  tag: latest\nservice:\n  type: ClusterIP\n  port: 80\n</code></pre>"},{"location":"devops/k8s/helm/#best-practices","title":"\ud83c\udf1f Best Practices","text":"<ol> <li> <p>Use Version Control for Charts:</p> <ul> <li>Store your Helm charts in a Git repository to track changes.</li> </ul> </li> <li> <p>Use <code>values.yaml</code> for Configuration:</p> <ul> <li>Keep default configurations in <code>values.yaml</code> and override them as needed.</li> </ul> </li> <li> <p>Test Charts Locally:</p> <ul> <li>Use <code>helm template</code> to render templates locally and verify the output: <code>helm template my-chart</code></li> </ul> </li> <li> <p>Use Chart Repositories:</p> <ul> <li>Publish your charts to a Helm repository for easy sharing and reuse.</li> </ul> </li> <li> <p>Monitor Releases:</p> <ul> <li>Use <code>helm list</code> and <code>helm history</code> to monitor the status and history of releases.</li> </ul> </li> </ol>"},{"location":"devops/k8s/helm/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li> <p>Helm Repositories:</p> <ul> <li>Add a repository: <code>helm repo add stable https://charts.helm.sh/stable</code></li> <li>Update repositories: <code>helm repo update</code></li> </ul> </li> <li> <p>Debugging:</p> <ul> <li>Use <code>helm install --dry-run --debug</code> to simulate an installation and debug issues.</li> </ul> </li> <li> <p>Helm Plugins:</p> <ul> <li>Extend Helm\u2019s functionality with plugins. Example: <code>helm plugin install https://github.com/databus23/helm-diff</code></li> </ul> </li> </ul>"},{"location":"devops/k8s/pods/","title":"Pods \u2013 The Smallest Unit in Kubernetes","text":""},{"location":"devops/k8s/pods/#what-is-a-pod","title":"\ud83e\udde0 What is a Pod?","text":"<p>A Pod is the smallest deployable unit in Kubernetes. It is a logical wrapper around one or more containers (usually just one) that share the same network namespace and storage.</p>"},{"location":"devops/k8s/pods/#analogy","title":"Analogy:","text":"<p>A pod is like a shipping container that wraps your application with everything it needs. If your app is a Docker container, Kubernetes doesn\u2019t run it directly. It runs a pod that contains it.</p>"},{"location":"devops/k8s/pods/#key-features-of-pods","title":"\ud83d\udee0 Key Features of Pods:","text":"<ol> <li> <p>Shared Network:</p> <ul> <li>All containers in a pod share the same IP address and port space.</li> <li>Containers communicate with each other via <code>localhost</code>.</li> </ul> </li> <li> <p>Shared Storage:</p> <ul> <li>Containers in a pod can share storage volumes.</li> </ul> </li> <li> <p>Ephemeral Nature:</p> <ul> <li>Pods are designed to be short-lived and disposable.</li> <li>Kubernetes manages their lifecycle and replaces them if they fail.</li> </ul> </li> <li> <p>Multi-Container Pods:</p> <ul> <li>A pod can contain multiple containers that work together (e.g., a main app container and a sidecar container for logging or monitoring).</li> </ul> </li> </ol>"},{"location":"devops/k8s/pods/#example-use-case","title":"\ud83d\udce6 Example Use Case","text":"<p>A pod might run: - A Python app container to handle requests. - A sidecar logging container to collect and forward logs. Both containers live in the same pod and share resources.</p>"},{"location":"devops/k8s/pods/#yaml-example-single-container-pod","title":"\ud83d\udd27 YAML Example: Single-Container Pod","text":"<p>Here\u2019s a simple YAML configuration for a pod:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app\nspec:\n  containers:\n    - name: app-container\n      image: my-app-image:latest\n</code></pre>"},{"location":"devops/k8s/pods/#explanation","title":"Explanation:","text":"<ul> <li>apiVersion: Specifies the Kubernetes API version.</li> <li>kind: Defines the resource type (in this case, <code>Pod</code>).</li> <li>metadata: Contains metadata like the pod's name.</li> <li>spec: Specifies the desired state of the pod.</li> <li>containers: Lists the containers in the pod.<ul> <li>name: Name of the container.</li> <li>image: The container image to use.</li> </ul> </li> </ul>"},{"location":"devops/k8s/pods/#yaml-example-multi-container-pod","title":"\ud83d\udd27 YAML Example: Multi-Container Pod","text":"<p>Here\u2019s an example of a pod with two containers:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: multi-container-pod\nspec:\n  containers:\n    - name: app-container\n      image: my-app-image:latest\n      ports:\n        - containerPort: 8080\n    - name: logging-container\n      image: logging-image:latest\n      args: [\"--log-path=/var/log/app\"]\n      volumeMounts:\n        - name: shared-logs\n          mountPath: /var/log/app\n  volumes:\n    - name: shared-logs\n      emptyDir: {}\n</code></pre>"},{"location":"devops/k8s/pods/#explanation_1","title":"Explanation:","text":"<ul> <li>Multi-Container Pod:</li> <li>The <code>app-container</code> runs the main application.</li> <li>The <code>logging-container</code> collects logs from the shared volume.</li> <li>volumeMounts: Mounts a shared volume (<code>shared-logs</code>) to both containers.</li> <li>volumes: Defines the shared volume (<code>emptyDir</code> is a temporary storage type).</li> </ul>"},{"location":"devops/k8s/pods/#pod-lifecycle","title":"\ud83d\udd04 Pod Lifecycle","text":"<p>Pods go through the following lifecycle phases:</p> <ol> <li> <p>Pending:    The pod is created but not yet scheduled to a node.</p> </li> <li> <p>Running:    The pod is scheduled to a node, and its containers are running.</p> </li> <li> <p>Succeeded:    All containers in the pod have completed successfully.</p> </li> <li> <p>Failed:    At least one container in the pod has terminated with an error.</p> </li> <li> <p>Unknown:    The state of the pod cannot be determined.</p> </li> </ol>"},{"location":"devops/k8s/pods/#best-practices","title":"\ud83d\udee1\ufe0f Best Practices","text":"<ol> <li> <p>Use Deployments:</p> <ul> <li>Pods are ephemeral. Use higher-level controllers like Deployments to manage pod replicas and ensure availability.</li> </ul> </li> <li> <p>Keep Pods Lightweight:</p> <ul> <li>Avoid running too many containers in a single pod unless they are tightly coupled.</li> </ul> </li> <li> <p>Use Sidecar Containers:</p> <ul> <li>For tasks like logging, monitoring, or proxying, use sidecar containers.</li> </ul> </li> <li> <p>Monitor Pod Health:</p> <ul> <li>Use liveness and readiness probes to monitor pod health and availability.</li> </ul> </li> </ol>"},{"location":"devops/k8s/pods/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li>Liveness Probes: Ensure the container is still running.</li> <li>Readiness Probes: Ensure the container is ready to serve traffic.</li> <li>emptyDir Volume: A temporary directory that is created when a pod is assigned to a node and exists as long as the pod is running.</li> </ul> <pre><code>livenessProbe:\n  httpGet:\n    path: /healthz\n    port: 8080\n  initialDelaySeconds: 3\n  periodSeconds: 3\n\nreadinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 5\n  periodSeconds: 5\n</code></pre> <p>These probes help Kubernetes decide whether to restart a container or remove it from the service endpoints.</p>"},{"location":"devops/k8s/pods/#common-commands-for-pods","title":"\ud83d\udee0\ufe0f Common Commands for Pods","text":"<p>Here are some commonly used <code>kubectl</code> commands to manage Pods:</p> <ol> <li> <p>List all Pods: <code>kubectl get pods</code></p> </li> <li> <p>Get detailed information about a Pod: <code>kubectl describe pod &lt;pod-name&gt;</code></p> </li> <li> <p>View Pod logs: <code>kubectl logs &lt;pod-name&gt;</code></p> </li> <li> <p>View logs for a specific container in a Pod: <code>kubectl logs &lt;pod-name&gt; -c &lt;container-name&gt;</code></p> </li> <li> <p>Execute a command inside a Pod: <code>kubectl exec -it &lt;pod-name&gt; -- &lt;command&gt;</code></p> <ul> <li>Example: <code>kubectl exec -it my-pod -- /bin/bash</code></li> </ul> </li> <li> <p>Delete a Pod: <code>kubectl delete pod &lt;pod-name&gt;</code></p> </li> <li> <p>Get Pod status: <code>kubectl get pod &lt;pod-name&gt; -o wide</code></p> </li> <li> <p>Port-forward a Pod to access it locally: <code>kubectl port-forward &lt;pod-name&gt; &lt;local-port&gt;:&lt;pod-port&gt;</code></p> <ul> <li>Example: <code>kubectl port-forward my-pod 8080:80</code></li> </ul> </li> <li> <p>Check Pod events: <code>kubectl get events --field-selector involvedObject.name=&lt;pod-name&gt;</code></p> </li> <li> <p>Debug a Pod by creating a temporary Pod: <code>kubectl run debug-pod --image=busybox -it --rm -- /bin/sh</code></p> </li> </ol>"},{"location":"devops/k8s/service/","title":"\ud83c\udf10 Services \u2013 Exposing Your Application","text":""},{"location":"devops/k8s/service/#what-is-a-service","title":"\ud83e\udde0 What is a Service?","text":"<p>A Service in Kubernetes is an abstraction that provides a stable network endpoint to expose your application. It allows communication between different components of your application (e.g., between microservices) or between external clients and your application.</p>"},{"location":"devops/k8s/service/#analogy","title":"\ud83e\udde0 Analogy:","text":"<p>Pods are like employees in a company \u2014 they come and go. A Service is like the company\u2019s public-facing phone number. It always routes to available employees (pods) that are ready to handle requests.</p>"},{"location":"devops/k8s/service/#key-features","title":"Key Features:","text":"<ol> <li>Stable IP and DNS: A Service provides a stable IP address and DNS name for pods, even if the pods are replaced.</li> <li>Load Balancing: Services can distribute traffic across multiple pods.</li> <li>Pod Discovery: Services use selectors to automatically discover and route traffic to matching pods.</li> </ol>"},{"location":"devops/k8s/service/#types-of-services","title":"\ud83d\udd11 Types of Services","text":"<ol> <li> <p>ClusterIP (default):</p> <ul> <li>Exposes the Service only within the cluster.</li> <li>Use case: Internal communication between microservices.</li> <li>Example: A backend service communicating with a database.</li> </ul> </li> <li> <p>NodePort:</p> <ul> <li>Exposes the Service on a static port on each node in the cluster.</li> <li>Use case: Accessing the application from outside the cluster (not recommended for production).</li> <li>Example: Testing an application locally.</li> </ul> </li> <li> <p>LoadBalancer:</p> <ul> <li>Creates an external load balancer (e.g., AWS ELB, GCP Load Balancer) to expose the Service to the internet.</li> <li>Use case: Exposing a public-facing application.</li> <li>Example: A web application accessible to users.</li> </ul> </li> <li> <p>ExternalName:</p> <ul> <li>Maps the Service to an external DNS name.</li> <li>Use case: Redirecting traffic to an external service (e.g., a third-party API).</li> <li>Example: Mapping <code>my-service</code> to <code>api.example.com</code>.</li> </ul> </li> </ol>"},{"location":"devops/k8s/service/#yaml-examples","title":"\ud83d\udd27 YAML Examples","text":""},{"location":"devops/k8s/service/#1-clusterip-service-default","title":"1. ClusterIP Service (Default)","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: my-app\n  ports:\n    - port: 80\n      targetPort: 8080\n  type: ClusterIP\n</code></pre> <ul> <li>selector: Matches pods with the label <code>app: my-app</code>.</li> <li>port: The port exposed by the Service.</li> <li>targetPort: The port on the pod where the application is running.</li> </ul>"},{"location":"devops/k8s/service/#2-nodeport-service","title":"2. NodePort Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: my-app\n  ports:\n    - port: 80\n      targetPort: 8080\n      nodePort: 30007\n  type: NodePort\n</code></pre> <ul> <li>nodePort: Exposes the Service on port <code>30007</code> on each node.</li> </ul>"},{"location":"devops/k8s/service/#3-loadbalancer-service","title":"3. LoadBalancer Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: my-app\n  ports:\n    - port: 80\n      targetPort: 8080\n  type: LoadBalancer\n</code></pre> <ul> <li>type: LoadBalancer: Creates an external load balancer to expose the Service.</li> </ul>"},{"location":"devops/k8s/service/#4-externalname-service","title":"4. ExternalName Service","text":"<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: external-service\nspec:\n  type: ExternalName\n  externalName: api.example.com\n</code></pre> <ul> <li>externalName: Maps the Service to the external DNS <code>api.example.com</code>.</li> </ul>"},{"location":"devops/k8s/service/#common-commands-for-services","title":"\ud83d\udee0\ufe0f Common Commands for Services","text":"<ol> <li> <p>List all Services:    <code>bash    kubectl get services</code></p> </li> <li> <p>Get detailed information about a Service:    <code>bash    kubectl describe service &lt;service-name&gt;</code></p> </li> <li> <p>Expose a Deployment as a Service:    <code>bash    kubectl expose deployment &lt;deployment-name&gt; --type=ClusterIP --port=80 --target-port=8080</code></p> </li> <li> <p>Delete a Service:    <code>bash    kubectl delete service &lt;service-name&gt;</code></p> </li> <li> <p>Port-forward a Service to access it locally:    <code>bash    kubectl port-forward service/&lt;service-name&gt; &lt;local-port&gt;:&lt;service-port&gt;</code>    Example:    <code>bash    kubectl port-forward service/my-service 8080:80</code></p> </li> </ol>"},{"location":"devops/k8s/service/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li> <p>Service Discovery:</p> <ul> <li>Kubernetes automatically creates a DNS entry for each Service.</li> <li>Example: A Service named <code>my-service</code> in the <code>default</code> namespace can be accessed at <code>http://my-service.default.svc.cluster.local</code>.</li> </ul> </li> <li> <p>Headless Services:</p> <ul> <li>If you don\u2019t need load balancing, you can create a headless Service by setting <code>clusterIP: None</code>.</li> <li>Use case: Direct communication with individual pods (e.g., for stateful applications like databases).</li> </ul> </li> </ul> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: headless-service\nspec:\n  selector:\n    app: my-app\n  clusterIP: None\n  ports:\n    - port: 80\n      targetPort: 8080\n</code></pre> <ul> <li> <p>Service Selectors:</p> <ul> <li>Services use selectors to match pods. If no pods match the selector, the Service will not route traffic.</li> </ul> </li> <li> <p>Ingress vs. Service:</p> <ul> <li>A Service exposes your application, while an Ingress provides advanced routing (e.g., path-based routing, SSL termination) for external traffic.</li> </ul> </li> </ul>"},{"location":"devops/k8s/service/#best-practices","title":"\ud83c\udf1f Best Practices","text":"<ol> <li> <p>Use ClusterIP for Internal Communication:</p> <ul> <li>Use <code>ClusterIP</code> Services for communication between microservices within the cluster.</li> </ul> </li> <li> <p>Avoid NodePort in Production:</p> <ul> <li><code>NodePort</code> is useful for testing but not recommended for production due to limited scalability and security concerns.</li> </ul> </li> <li> <p>Use LoadBalancer for Public-Facing Applications:</p> <ul> <li>Use <code>LoadBalancer</code> Services to expose applications to the internet.</li> </ul> </li> <li> <p>Monitor Service Health:</p> <ul> <li>Use tools like Prometheus and Grafana to monitor Service performance and traffic.</li> </ul> </li> <li> <p>Leverage Labels and Selectors:</p> <ul> <li>Use meaningful labels to organize and manage your Services and pods effectively.</li> </ul> </li> </ol>"},{"location":"devops/k8s/volume/","title":"\ud83d\udcbe Volumes, PV, PVC \u2013 Persistent Storage in Kubernetes","text":""},{"location":"devops/k8s/volume/#what-are-volumes-pv-and-pvc","title":"\ud83e\udde0 What are Volumes, PV, and PVC?","text":"<p>Kubernetes provides a way to manage storage for pods using Volumes, PersistentVolumes (PV), and PersistentVolumeClaims (PVC). These abstractions allow pods to use storage that persists beyond the lifecycle of the pod.</p>"},{"location":"devops/k8s/volume/#analogy","title":"\ud83e\udde0 Analogy:","text":"<ul> <li>Pods are like laptops \u2014 they can crash or be replaced.</li> <li>A Volume is like an external hard drive you plug into the laptop. Even if the laptop dies, the drive can be re-used.</li> <li>PersistentVolume (PV): A physical disk in the cluster (e.g., cloud storage, NFS, or local disk).</li> <li>PersistentVolumeClaim (PVC): A request for storage made by a pod.</li> </ul>"},{"location":"devops/k8s/volume/#simplified-analogy","title":"Simplified Analogy:","text":"<ul> <li>PV = A shared drive available in the office.</li> <li>PVC = Someone asking, \u201cI need 10 GB of space for my work.\u201d</li> <li>Volume = How the pod plugs into that shared drive.</li> </ul>"},{"location":"devops/k8s/volume/#key-concepts","title":"\ud83d\udd11 Key Concepts","text":"<ol> <li> <p>Volume:</p> <ul> <li>A directory accessible to containers in a pod.</li> <li>Types:<ul> <li>emptyDir: Temporary storage that exists as long as the pod is running.</li> <li>hostPath: Mounts a directory from the host node.</li> <li>persistentVolumeClaim: Connects to a PersistentVolume.</li> </ul> </li> </ul> </li> <li> <p>PersistentVolume (PV):</p> <ul> <li>A cluster-wide storage resource.</li> <li>Provisioned by an admin or dynamically created by a StorageClass.</li> </ul> </li> <li> <p>PersistentVolumeClaim (PVC):</p> <ul> <li>A request for storage by a pod.</li> <li>Binds to a PV that satisfies the request.</li> </ul> </li> </ol>"},{"location":"devops/k8s/volume/#example-persistentvolumeclaim-pvc","title":"\ud83d\udd27 Example: PersistentVolumeClaim (PVC)","text":"<p>Here\u2019s an example of a PVC requesting 1Gi of storage:</p> <pre><code>apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: my-pvc\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\n</code></pre>"},{"location":"devops/k8s/volume/#explanation","title":"Explanation:","text":"<ul> <li>accessModes:</li> <li><code>ReadWriteOnce</code>: The volume can be mounted as read-write by a single node.</li> <li><code>ReadOnlyMany</code>: The volume can be mounted as read-only by many nodes.</li> <li><code>ReadWriteMany</code>: The volume can be mounted as read-write by many nodes.</li> <li>resources.requests.storage: The amount of storage requested (e.g., 1Gi).</li> </ul>"},{"location":"devops/k8s/volume/#example-persistentvolume-pv","title":"\ud83d\udd27 Example: PersistentVolume (PV)","text":"<p>Here\u2019s an example of a PV backed by NFS:</p> <pre><code>apiVersion: v1\nkind: PersistentVolume\nmetadata:\n  name: my-pv\nspec:\n  capacity:\n    storage: 1Gi\n  accessModes:\n    - ReadWriteOnce\n  nfs:\n    path: /path/to/nfs\n    server: nfs-server.example.com\n</code></pre>"},{"location":"devops/k8s/volume/#explanation_1","title":"Explanation:","text":"<ul> <li>capacity.storage: The total storage capacity of the PV.</li> <li>accessModes: Defines how the volume can be accessed.</li> <li>nfs: Specifies the NFS server and path.</li> </ul>"},{"location":"devops/k8s/volume/#example-using-pvc-in-a-pod","title":"\ud83d\udd27 Example: Using PVC in a Pod","text":"<p>Here\u2019s how to use a PVC in a pod:</p> <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-pod\nspec:\n  containers:\n    - name: my-container\n      image: nginx\n      volumeMounts:\n        - mountPath: /usr/share/nginx/html\n          name: my-volume\n  volumes:\n    - name: my-volume\n      persistentVolumeClaim:\n        claimName: my-pvc\n</code></pre>"},{"location":"devops/k8s/volume/#explanation_2","title":"Explanation:","text":"<ul> <li>volumeMounts: Mounts the volume inside the container at <code>/usr/share/nginx/html</code>.</li> <li>volumes.persistentVolumeClaim.claimName: Refers to the PVC <code>my-pvc</code>.</li> </ul>"},{"location":"devops/k8s/volume/#common-commands-for-volumes-pv-and-pvc","title":"\ud83d\udee0\ufe0f Common Commands for Volumes, PV, and PVC","text":"<ol> <li> <p>List all PersistentVolumes (PV): <code>kubectl get pv</code></p> </li> <li> <p>List all PersistentVolumeClaims (PVC): <code>kubectl get pvc</code></p> </li> <li> <p>Describe a PersistentVolume (PV): <code>kubectl describe pv &lt;pv-name&gt;</code></p> </li> <li> <p>Describe a PersistentVolumeClaim (PVC): <code>kubectl describe pvc &lt;pvc-name&gt;</code></p> </li> <li> <p>Delete a PersistentVolumeClaim (PVC): <code>kubectl delete pvc &lt;pvc-name&gt;</code></p> </li> <li> <p>Check which PV is bound to a PVC: <code>kubectl get pvc &lt;pvc-name&gt; -o wide</code></p> </li> </ol>"},{"location":"devops/k8s/volume/#best-practices","title":"\ud83c\udf1f Best Practices","text":"<ol> <li> <p>Use Dynamic Provisioning:</p> <ul> <li>Use a StorageClass to dynamically provision PVs instead of manually creating them.</li> </ul> </li> <li> <p>Set Resource Requests and Limits:</p> <ul> <li>Define appropriate storage requests in your PVC to avoid over-provisioning.</li> </ul> </li> <li> <p>Monitor Storage Usage:</p> <ul> <li>Use tools like Prometheus and Grafana to monitor storage usage and performance.</li> </ul> </li> <li> <p>Use Access Modes Wisely:</p> <ul> <li>Choose the correct access mode (<code>ReadWriteOnce</code>, <code>ReadOnlyMany</code>, <code>ReadWriteMany</code>) based on your application\u2019s requirements.</li> </ul> </li> <li> <p>Clean Up Unused PVCs:</p> <ul> <li>Delete unused PVCs to free up storage resources.</li> </ul> </li> </ol>"},{"location":"devops/k8s/volume/#additional-notes","title":"\ud83d\udd0d Additional Notes","text":"<ul> <li>Dynamic Provisioning:<ul> <li>Use a <code>StorageClass</code> to automatically provision PVs when a PVC is created.</li> <li>Example:</li> </ul> </li> </ul> <pre><code>apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: standard\nprovisioner: kubernetes.io/aws-ebs\nparameters:\n  type: gp2\n</code></pre> <ul> <li>Reclaim Policy:<ul> <li>PVs have a <code>reclaimPolicy</code> that determines what happens when a PVC is deleted:<ul> <li><code>Retain</code>: Keeps the PV for manual cleanup.</li> <li><code>Delete</code>: Deletes the PV automatically.</li> <li><code>Recycle</code>: Clears the PV for reuse (deprecated).</li> </ul> </li> </ul> </li> </ul>"}]}